<!DOCTYPE html>
<!-- Author: Andrew Jarombek
     Date: 12/12/2017 -->
<html>
    <head>
        <meta chartset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Creating a Node.js and MongoDB REST API Prototype</title>
        <link rel="stylesheet" href="../../../blog-discover.css">
        <link rel="stylesheet" href="style/nodejs-mongodb.css">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/fantasque-sans-mono" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" 
            integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
        <link href="../../../prism.css" rel="stylesheet" />
    </head>
    <body>
        <div class="col-md-12 discoveryBody">
            <div class="col-md-12 discoveryContent">
                <p class="date">December 30th, 2017</p>
                <br>
                <h4>Creating a Node.js and MongoDB REST API Prototype</h4>
                <br>
                <div class="container aknowledge">
                    <p>Assumed Knowledge:</p>
                    <p>MongoDB <span class="badge badge-warning">Intermediate</span></p>
                    <p>Node.js <span class="badge badge-warning">Intermediate</span></p>
                    <p>Express <span class="badge badge-warning">Intermediate</span></p>
                    <p>JavaScript <span class="badge badge-warning">Intermediate</span></p>
                    <p>REST <span class="badge badge-default">Basic</span></p>
                </div><br>
                <div id="discoveryText" class="container">
                    <p>
                        Most of my discoveries lately have been about JavaScript.   This includes learning the new ES6 syntax and features along with all the 
                        quirks that come with the JavaScript language.  Recently I have been exploring the MongoDB database and Node.js environment.  
                        MongoDB is a NoSQL database that allows you to store JSON formatted documents in a schema-less model.  I wrote four discovery 
                        posts on MongoDB starting with the 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/12-Dec/12-15-MongoDB-Pt1/View">basic features of the database</a>
                        .  While I haven't written any discoveries with Node.js as the main focus, I have experimented with it when testing out 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/11-Nov/11-10-ES6-Modules-Babel/View">ES6 modules with Babel</a> 
                        and 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/11-Nov/11-26-JS-Async-Function/View">Async Functions</a>.  
                    </p>
                    <p>
                        All of this knowledge buildup is for a personal website project that I have planned (and where this blog will call home!).  
                        Before I start development on the website directly, I will create a series of prototypes to get a feel for some of the 
                        technologies I will use in my websites stack.  With these prototypes I can make sure the technology I choose is a good fit for 
                        the full project.  Also I can use them as templates to complete future discoveries!  In general if you have the time to build 
                        prototypes with technologies you want to use in a production project it is a great idea!
                    </p>
                    <p>
                        My planned production web stacks will be either MEAN (MongoDB, Express, <strong>Angular</strong>, Node.js) or MERN (MongoDB, Express, <strong>React.js</strong>, 
                        Node.js).  You will notice that three of these technologies are present in both stacks - <strong>MongoDB, Express,</strong> and <strong>Node.js</strong>.  We will 
                        be using all three to build the prototype today!
                    </p>
                    <h5>Prototype Structure</h5>
                    <p>
                        The prototype is a REST API that lets users look at songs and artists.  They can also comment on songs.  MongoDB stores this 
                        information in a database called <code>music_api</code>.  Databases in MongoDB are simply namespaces, which is much different than 
                        their Relational Database equivalents.  In a RDBMS you need a username and password among other items to connect to a certain 
                        database.  MongoDB does not have this requirement. 
                    </p>
                    <p>
                        The data is then stored in collections of documents including songs, artists, and end users.
                    </p>
                    <figure id="mongo-image">
                        <img src="mongodb.png">
                    </figure>
                    <p>
                        The Node.js run-time environment and Express web application framework then expose a REST API to users so they can query, create, 
                        update, and delete items in the database (all CRUD operations).  
                    </p>
                    <figure id="restapi-image">
                        <img src="restapi.png">
                    </figure>
                    <p>
                        For the prototype most of the functionality surrounds viewing and manipulating songs, however in a full application these uses would 
                        be expanded.  This could include creating and updating users, rating songs, user-to-user interactivity, etc.  Now let's look at some 
                        insteresting aspects of the prototype and certain challenges that I faced while creating it.
                    </p>
                    <h5>Using Mongoose</h5>
                    <p>
                        For interacting with the MongoDB database from Node.js I chose to use a module called Mongoose.  Mongoose allows you to model database 
                        JSON objects and perform all MongoDB queries, inserts, and updates.  With MongoDB you don't really need to use a ORM (Object Relational 
                        Mapping) framework since all the data is already in JSON form which any programming language can deal with.  However, Mongoose gives us 
                        some additional capabilities which make it desirable.  
                    </p>
                    <p>
                        First off Mongoose allows you to set strict schema rules for your MongoDB objects.  As previously mentioned MongoDB is 
                        schema-less so this stricter model can help restrict what exactly a user can place in a document.  You can also create nested schemas 
                        for complex JSON documents.  For example, my song collection schema contains a nested schema for a list of comments.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const Schema = mongoose.Schema;
                                
const SongSchema = new Schema({
    title: {
        type: String,
        trim: true,
        required: true
    },
    album: {
        type: String,
        trim: true
    },
    artist: {
        type: String,
        trim: true,
        required: true
    },
    artist_id: Schema.Types.ObjectId,
    type: {
        type: String,
        enum: ['a', 'j', 'aj']
    },
    release_date: {
        type: Date,
        default: Date.now()
    },
    best_lyric: String,
    comments: [{
        type: CommentSchema
    }]
}, {usePushEach: true});</code>
                        </pre>
                    </figure>
                    <p>
                        You can see that each <code>Schema()</code> constructor function takes a JSON object that represents all the properties of the 
                        MongoDB document.  You can also add additional validations, such as making certain fields required (<code>required: true</code>) or 
                        having a default value (<code>default: Date.now()</code>)<sup>1</sup>.  When a user uploads a JSON object to a schema and tries updating the 
                        database, only the properties seen in the schema will be persisted to MongoDB.
                    </p>
                    <p>
                        Also there is a comments property which takes an array of type <code>CommentSchema</code>.  This <code>CommentSchema</code> can 
                        be defined similarly to how I implemented <code>SongSchema</code>.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const CommentSchema = new Schema({
    username: String,
    user_id: Schema.Types.ObjectId,
    date: {
        type: Date,
        default: Date.now()
    },
    content: {
        type: String,
        trim: true
    }
}, {usePushEach: true, _id : false});</code>
                        </pre>
                    </figure>
                    <p>
                        Another powerful feature of MongoDB is that we can define database indexes directly on the <code>Schema</code> object.  With features 
                        such as this one Mongoose has transformed into something much more powerful than a ORM.  With Mongoose I did not even have to go into 
                        MongoDB itself since everything I needed could be performed through Mongoose.  Here is an index I made on the <code>name</code> property
                        in the artist schema.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">ArtistSchema.index({name: 1});</code>
                        </pre>
                    </figure>
                    <h5>Switching to Promises</h5>
                    <p>
                        Mongoose allows you to perform any query, update, insert, or delete operation on a Schema.  By default however, Mongoose uses callbacks 
                        to perform these operations.  We want to avoid callbacks as they become ugly and hard to read once nested database calls need to be made (commonly 
                        known as callback hell).  Luckily Mongoose allows us to use 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/11-Nov/11-21-JS-Promises">ES6 Promises</a> 
                        instead<sup>2</sup>.  One of the first things I did when creating my API 
                        calls was to replace all the callbacks I could with Promises.  Here is some code that performs a <code>find</code> operation on the 
                        <code>Song</code> schema and then returns it to as a HTTP response using a promise.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">Song.find().exec()
    .then((songs) => {
        res.format({
            'application/json': () => {
                res.json(songs);
            },
            'application/xml': () => {
                res.render('xml/songs', {songs: songs});
            }
        });
    })
    .catch((err) => {
        console.error(err);
        res.status(500).send(err);
    });</code>
                        </pre>
                    </figure>
                    <h5>Using EJS to Return XML</h5>
                    <p>
                        You may have noticed in the last code sample the <code>res.format()</code> function which returns the song data as an HTTP response.  
                        This function also returns either JSON or XML depending on the MIME type specified in the HTTP requests <code>Accept</code> header.  
                        Normally I don't think the development work needed to return both notations would be worth it but Express made it so easy to implement<sup>3</sup>!
                    </p>
                    <p>
                        There are two ways to implement the conversion to XML.  One option is to perform it in JavaScript itself<sup>4</sup>.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">'application/xml': () => {
    res.write('<songs>\n');

    songs.forEach((song) => {
        let comments = "";
        song.comments.forEach((comment) => {
            comments = `
                ${comments}
                &lt;comment&gt;
                    &lt;username&gt;${comment.username}&lt;/username&gt;
                    &lt;date&gt;${comment.date}&lt;/date&gt;
                    &lt;content&gt;${comment.content}&lt;/content&gt;
                &lt;/comment&gt;
            `;
        });

        res.write(`
            &lt;entry&gt;
                &lt;title&gt;${song.title}&lt;/title&gt;
                &lt;artist&gt;${song.artist}&lt;/artist&gt;
                &lt;album&gt;${song.album}&lt;/album&gt;
                &lt;type&gt;${song.type}&lt;/type&gt;
                &lt;release_date&gt;${song.release_date}&lt;/release_date&gt;
                &lt;best_lyric&gt;${song.best_lyric}&lt;/best_lyric&gt;
                &lt;comments&gt;${comments}&lt;/comments&gt;
            &lt;/entry&gt;
        `);
    });
    res.end('&lt;/songs&gt;');
}</code>
                        </pre>
                    </figure>
                    <p>
                        This is a bit messy as you are mixing JavaScript and a markup language together.  A more elegant solution would be to use a tempting 
                        language to generate the XML.  The template language I used is EJS (embedded javascript templating) which mixes JavaScript with HTML 
                        similarly to JSP for Java or PHP (which I used in my 
                        <a href="https://github.com/AJarombek/saints-xctf">saintsxctf.com website</a>
                        )<sup>5</sup>.  We then use this template to create the 
                        markup on the server using JavaScript before sending it to the client.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-html" title="EJS" contenteditable="true" spellcheck="false">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;songs&gt;
    &lt;% for (var i = 0; i &lt; songs.length; i++) { %&gt;
        &lt;song&gt;
            &lt;_id&gt;&lt;%= songs[i]._id %&gt;&lt;/_id&gt;
            &lt;title&gt;&lt;%= songs[i].title %&gt;&lt;/title&gt;
            &lt;artist&gt;&lt;%= songs[i].artist %&gt;&lt;/artist&gt;
            &lt;album&gt;&lt;%= songs[i].album %&gt;&lt;/album&gt;
            &lt;type&gt;&lt;%= songs[i].type %&gt;&lt;/type&gt;
            &lt;release_date&gt;&lt;%= songs[i].release_date %&gt;&lt;/release_date&gt;
            &lt;best_lyric&gt;&lt;%= songs[i].best_lyric %&gt;&lt;/best_lyric&gt;
            &lt;comments&gt;
                &lt;% for (var j = 0; j &lt; songs[i].comments.length; j++) { %&gt;
                    &lt;comment&gt;
                        &lt;username&gt;&lt;%= songs[i].comments[j].username %&gt;&lt;/username&gt;
                        &lt;date&gt;&lt;%= songs[i].comments[j].date %&gt;&lt;/date&gt;
                        &lt;content&gt;&lt;%= songs[i].comments[j].content %&gt;&lt;/content&gt;
                    &lt;/comment&gt;
                &lt;% } %&gt;
            &lt;/comments&gt;
        &lt;/song&gt;
    &lt;% } %&gt;
&lt;/songs&gt;</code>
                        </pre>
                    </figure>
                    <p>
                        One drawback of this approach is that all the JavaScript code I wrote in the EJS template was in ES5.  Babel is unable to 
                        transpile EJS so if you write ES6 all browsers must be ES6 compatible.  Therefore I settled for ES5 just to be safe.  Here you 
                        can see the XML result in postman:
                    </p>
                    <figure id="xmlresponse-image">
                        <img src="xmlresponse.png">
                    </figure>
                    <h5>Text Search</h5>
                    <p>
                        Text searching is how search engines take user input and return a list of results.  The full picture of how it works is beyond the 
                        scope of this blog (although it would make for a fun discovery some day!) but just know that MongoDB allows for a barebones version of 
                        text searching.  You can implement a text search by defining an index of type <code>’text’</code> on a property (most likely you will 
                        define it on a string but you could even place it on an array)<sup>6</sup>.  MongoDB will do the rest of the work for you.  Weights 
                        can also be placed on properties to specify how important a certain field is for a search<sup>7</sup>.
                    </p>
                    <p>
                        Remember how I said practically anything you wanted to do in MongoDB can be done in Node.js using Mongoose?  You can implement 
                        a text search and its necessary indexes as well<sup>8</sup>!  Here are the indexes which are placed on the <code>SongSchema</code>:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">SongSchema.index(
    {
        'title': 'text',
        'album': 'text',
        'artist': 'text',
        'best_lyric': 'text'
    },
    {
        'weights': {
            'title': 10,
            'album': 5,
            'artist': 8,
            'best_lyric': 2
        }
    }
);</code>
                        </pre>
                    </figure>
                    <p>
                        Then you can perform the text search using Mongoose:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">searchRouter.route('/:query')
    .get((req, res) => {

        // Perform a text search and sort based on the text score.
        // The score is calculated by the indexes placed in the database
        Song.find({ "$text": {"$search": req.params.query}})
            .select({"score": {"$meta": "textScore"}})
            .sort({"score": {"$meta": "textScore"}}).exec()
            .then((songs) => {
                res.format({
                    'application/json': () => {
                        res.json(songs);
                    },
                    'application/xml': () => {
                        res.render('xml/songs', {songs: songs});
                    }
                });
            })
            .catch((err) => {
                res.status(500).send(err);
            });
    });</code>
                        </pre>
                    </figure>
                    <p>
                        Now a text search can be executed on the song collection.  When a text string is entered, it will be matched on values in the songs 
                        <code>title</code>, <code>artist</code>, <code>album</code>, and <code>best_lyric</code> fields.  When I search the word ‘faith’, it 
                        matches a Mariah Carey song with a matching lyric:
                    </p>
                    <figure id="xmlresponsetext-image">
                        <img src="xmlresponsetext.png">
                    </figure>
                    <h5>Basic Auth</h5>
                    <p>
                        I also found a really nice library to add basic auth to my endpoints.  Basic auth works by using the HTTP requests 
                        <code>Authorization</code> header to check for a base64 encoded credential string.  This credential string before being encoded has 
                        the form &lt;username&gt;:&lt;password&gt; followed by the unicode pound sign (U+00A3)<sup>9</sup>.
                    </p>
                    <p>
                        All you need to do to implement basic auth in an express app is pass the module a JSON object of usernames and passwords to accept<sup>10</sup>.  
                        This is yet another example of how user made npm modules can make Node.js development easy.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">app.use(basicAuth({
    users: {'a': 'j'}
}));</code>
                        </pre>
                    </figure>
                    <h5>Gulp</h5>
                    <p>
                        The final major piece of this prototype was the build automation tool - gulp.  Gulp allows you to build your project in stages 
                        using tasks defined as JavaScript functions<sup>11</sup>.  I am still trying to get a hang of gulp but I made a build file that watches 
                        for any file changes and automatically restarts the Express server with the changes applied.  In the process, gulp uses babel to transpile 
                        all the ES6+ files into ES5 and moves these transpiled files into a new directory.  I also move all my EJS files into this new directory.  
                        The code is very hackish (as I don’t know gulp well) but gets the job done!
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">
// The main task called.  We first execute the 'watch' task and then run a script 
// to start the server
gulp.task('default', ['watch'], () => {
    nodemon({
        script: './dist/app.js',
        ext: 'js',
        env: {
            PORT: 3000
        },
        ignore: [
            './node_modules/**',
            './dist/**/*.js',
            './dist/**/*.map',
            './package.json',
            './package-lock.json',
            './dbscripts/**'
        ]

    }).on('restart', () => {
        // Nodemon will restart the server when any of the src files change
        console.info('Restarting Server with Changes');
    });
});

// The 'watch' task will wait for changes in the source files and when they occur invoke
// the 'transpile' task.
gulp.task('watch', ['transpile', 'move'], () => {
    livereload.listen();
    gulp.watch('./src/**/*.js', ['transpile']);
    gulp.watch('./src/view/**/*.ejs', ['move']);
});

// The transpile task invokes babel to convert ES6+ code into ES5
gulp.task('transpile', () => {
    gulp.src('./src/**/*.js')
        .pipe(sourcemaps.init())
        .pipe(babel({
            presets: ['env']
        }))
        .pipe(sourcemaps.write('.'))
        .pipe(gulp.dest('./dist'))
        .pipe(livereload());
});

// The move task takes out ejs files used for xml generation and puts them in the dist folder
gulp.task('move', () => {
    gulp.src('./src/view/**/*.ejs')
        .pipe(gulp.dest('./dist/view'));
});</code>
                        </pre>
                    </figure>
                    <p>
                        Now all I have to do to run my server is enter one command in bash:
                    </p>
                    <figure>
                        <pre class="command-line" data-prompt="$">
                            <code class="language-bash" title="Bash" contenteditable="true" spellcheck="false">gulp</code>
                        </pre>
                    </figure>
                    <p>
                        Gulp made my life a lot easier in this project.  Combining gulp which restarted my server on all changes and the WebStorm IDE 
                        which automatically saves files, I never had to save a file or restart my server throughout development.  I could put 100% of my 
                        focus on developing!
                    </p>
                    <h5>Conclusions</h5>
                    <p>
                        This MongoDB and Node.js prototype was very enjoyable to make and has really made the full JavaScript stack grow on me.  There are 
                        still many unexplored areas of Node.js development for me but it is clear why this server side environment was such a game changer.  
                        I look forward to adding on a client side framework in the future!
                    </p>
                    <p>
                        The code for the prototype is available on my 
                        <a href="https://github.com/AJarombek/nodejs-mongodb-api-prototype">GitHub</a>. 
                    </p>
                    <div class="container tags">
                        <p>
                            Tags: <span class="badge badge-default">MongoDB</span> <span class="badge badge-default">Node.js</span> <span class="badge badge-default">Express</span>
                            <span class="badge badge-default">JavaScript</span> <span class="badge badge-default">ECMAScript 6</span> <span class="badge badge-default">NoSQL</span> <span class="badge badge-default">Document Database</span>
                            <span class="badge badge-default">Mongoose</span> <span class="badge badge-default">Babel</span> <span class="badge badge-default">Gulp</span> <span class="badge badge-default">REST</span>
                        </p>
                    </div>
                    <div class="container sources">
                        <p>[1] Amos Haviv, MEAN Web Development, 2nd ed (Birmingham, UK: Packt, 2016), 110</p>
                        <p>[2] "Built-in Promises", http://mongoosejs.com/docs/promises.html</p>
                        <p>[3] Alex Young, Bradley Meck, Mike Cantelon, Node.js In Action, 2nd ed (Shelter Island, NY: Manning, 2017), 156</p>
                        <p>[4] Young., 157</p>
                        <p>[5] Young., 158</p>
                        <p>[6] Kyle Banker, Peter Bakkum, Shaun Verch, Douglas Garrett &amp; Tom Hawkins, MongoDB In Action, 2nd ed (Shelter Island, NY: Manning, 2016), 252</p>
                        <p>[7] Banker., 255</p>
                        <p>[8] "Mongoose - Search for text in three fields based on score or weightage", https://stackoverflow.com/questions/32063998/mongoose-search-for-text-in-three-fields-based-on-score-or-weightage</p>
                        <p>[9] "The 'Basic' HTTP Authentication Scheme", https://tools.ietf.org/html/rfc7617</p>
                        <p>[10] "express-basic-auth", https://www.npmjs.com/package/express-basic-auth</p>
                        <p>[11] Young., 73</p>
                    </div>
                </div>
            </div>
        </div>
        <script src="../../../prism.js"></script>
    </body>
</html>