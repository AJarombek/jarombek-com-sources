<!DOCTYPE html>
<!-- Author: Andrew Jarombek
     Date: 12/12/2017 -->
<html>
    <head>
        <meta chartset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Creating a MEAN Stack Prototype</title>
        <link rel="stylesheet" href="../../../blog-discover.css">
        <link rel="stylesheet" href="style/mean-stack.css">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/fantasque-sans-mono" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" 
            integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
        <link href="../../../prism.css" rel="stylesheet" />
    </head>
    <body>
        <div class="col-md-12 discoveryBody">
            <div class="col-md-12 discoveryContent">
                <p class="date">March 17th, 2018</p>
                <br>
                <h4>Creating a MEAN Stack Prototype</h4>
                <br>
                <div class="container aknowledge">
                    <p>Assumed Knowledge:</p>
                    <p>Angular <span class="badge badge-warning">Intermediate</span></p>
                    <p>Node.js <span class="badge badge-warning">Intermediate</span></p>
                    <p>Express <span class="badge badge-warning">Intermediate</span></p>
                    <p>MongoDB <span class="badge badge-warning">Intermediate</span></p>
                    <p>JavaScript <span class="badge badge-warning">Intermediate</span></p>
                    <p>TypeScript <span class="badge badge-warning">Intermediate</span></p>
                    <p>HTML <span class="badge badge-default">Basic</span></p>
                    <p>REST <span class="badge badge-default">Basic</span></p>
                </div><br>
                <div id="discoveryText" class="container">
                    <p>
                        Much of my work lately has been in preparation for a personal website that I am going to build (and where this blog post 
                        will call home!).  The website is going to contain my resume, blog posts, discovery posts, and more.  I am really excited 
                        to get started building it!
                    </p>
                    <p>
                        The first order of business however is to decide which technology stack I want to use for the website.  I have narrowed it 
                        down to a full JavaScript stack, from the front-end through the database.  There are two remaining tech stacks in competition: 
                        the MEAN stack (MongoDB, Express, Angular, &amp; Node.js) and the MERN stack (MongoDB, Express, React.js &amp; Node.js).  I started 
                        the journey of deciding by reading many JavaScript books and writing plenty of discovery posts about them.  I also explored Node.js 
                        and MongoDB in depth.  I even made a 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Blogs/2017/12-30-NodeJS-MongoDB-API-Prototype">blog post</a> and 
                        <a href="https://github.com/AJarombek/nodejs-mongodb-api-prototype">prototype</a>
                         on both the technologies!  Now it is time to pick between the two front 
                        end JavaScript frameworks: Angular by Google and React.js by Facebook.  
                    </p>
                    <p>
                        This blog post is my journey through creating a prototype with Angular.  I will look at the prototype at a higher level and deep dive 
                        into code that makes the website function.  All along the way I will give my thoughts about Angular and all the other technologies that 
                        I learned along the way.  I will conclude with my current thoughts on Angular and what I feel React.js needs to bring to the table to 
                        defeat it!
                    </p>
                    <p>
                        I had a lot of fun (for the most part!) building with Angular, so let’s get started!
                    </p>
                    <h5>The Prototype</h5>
                    <p>
                        The MEAN stack prototype was a website that allows its users to upload cat pictures!  Appropriately, the website is named MeowPics.
                    </p>
                    <figure id="meowcat-image">
                        <img src="meowcat.png">
                    </figure>
                    <p>
                        The MongoDB, Express, Angular, and Node.js technology stack works as follows:
                    </p>
                    <figure id="meanstack-image">
                        <img src="MEAN-Stack.png">
                    </figure>
                    <p>
                        The first piece of the technology stack for MeowPics that I will walkthrough is the MongoDB document database.
                    </p>
                    <h5>MongoDB Structure</h5>
                    <p>
                        I have 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/12-Dec/12-15-MongoDB-Pt1">written</a> 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/12-Dec/12-16-MongoDB-Pt2">many</a> 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/12-Dec/12-23-MongoDB-Pt3">discovery</a> 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/12-Dec/12-27-MongoDB-Pt4">posts</a> on MongoDB in the past, but in general terms it is a NoSQL document database that stores data in collections 
                        of objects.  I used it extensively in my Node.js and MongoDB prototype as well.  The biggest reason I want to use MongoDB in my website is that 
                        it fits the JavaScript web stack since its queries are in JavaScript and objects are BSON (Binary JSON).
                    </p>
                    <p>
                        The MongoDB database for MeowPics has two main collections for users and cat posts.  There is also an audit collection that is used for logging 
                        purposes when updates, inserts, or deletions are made to documents in the user or post collections.
                    </p>
                    <p>
                        Here are some insert statements that show the structure of the user and post collections:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">db.user.insertMany([
    {
        username: "andy",
        first: "Andrew",
        last: "Jarombek",
        password: "$2a$10$c/DwED6TayK0d3ce5761zOTBBsnCB.JMpcF4l4Zojqti6Adaym9W2",
        postCount: 4
    },
    {
        username: "tom",
        first: "Thomas",
        last: "Caulfield",
        password: "$2a$10$8Irw8CAvdJr2uBAUYdlinOf8T9dblJiz0mumgNyfiHGBmT9vUweo6",
        postCount: 2
    }
]);

let andy_id = db.user.findOne({username: "andy"})._id;
let tom_id = db.user.findOne({username: "tom"})._id;
    
db.post.insertMany([
    {
        picture: "russianblue.jpg",
        name: "Cat Pic",
        username: "andy",
        user_id: andy_id,
        first: "Andrew",
        last: "Jarombek",
        date: new Date("2018-02-26"),
        description: "I love this picture!",
        up: 1,
        down: 0
    },
    {
        picture: "toms-cat.jpg",
        name: "Kitty!",
        username: "tom",
        user_id: tom_id,
        first: "Thomas",
        last: "Caulfield",
        date: new Date("2018-02-24"),
        description: "awww!",
        up: 5,
        down: 1
    }
]);</code>
                        </pre>
                    </figure>
                    <p>
                        While these statements are performed on the MongoDB database directly, most of my interactions were done through Mongoose.  
                        Mongoose is a Node.js module that allows you to model objects from MongoDB as well as performing queries, inserts, updates 
                        and more.  It is a really powerful tool that I used in my Node.js and MongoDB prototype.  For that prototype I was using 
                        version 4 of Mongoose.  I was really excited to see that in early January Mongoose 5 was released, which took big steps by 
                        using Promises by default and support for async functions<sup>1</sup>!  Let’s take a look at Mongoose 5 and the rest of 
                        the Node.js/Express API.
                    </p>
                    <h5>Node.js REST API</h5>
                    <p>
                        The Node.js/Express API defines three main routes and one for developer testing.  The three main routes are for users, 
                        posts, and authentication.  The users and posts routes define a CRUD API for both corresponding MongoDB collections.  Here is 
                        the entry point code to the server application:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const helmet = require('helmet');

const Post = require('./model/post');
const User = require('./model/user');
const Test = require('./model/test');
const Audit = require('./model/audit');

const userRouter = require('./route/userRouter')(User, Audit);
const postRouter = require('./route/postRouter')(Post, User, Audit);
const authRouter = require('./route/authRouter')(User);
const testRouter = require('./route/testRouter')(Test);

// Mongoose 5.0 uses native JS Promises by default (less config needed!)
mongoose.connect('mongodb://127.0.0.1/meowcat');

const app = express();

// Set a larger payload limit for HTTP requests since some image data will be large
app.use(bodyParser.urlencoded({extended: true, limit: '50mb'}));
app.use(bodyParser.json({limit: '50mb'}));

// Helps protect our API endpoint from well known web security vulnerabilities
app.use(helmet({}));

const port = process.env.port || 3000;

app.use('/api/test', testRouter);
app.use('/api/user', userRouter);
app.use('/api/post', postRouter);
app.use('/api/auth', authRouter);

app.get('/', (req, res) => {
    res.send(JSON.parse('{"title":"Welcome to the Apps API!"}'));
});

module.exports = app.listen(port, () => {
    console.info(`Started MeowCat API on port ${port}`);
});</code>
                        </pre>
                    </figure>
                    <p>
                        If you have seen an Express application before this should look familiar.  Some important points are that we are using Mongoose 
                        5, which requires less startup configuration.  I also had to set the <code>limit</code> property for <code>bodyParser</code> 
                        because the client may be sending large cat images to the server.  Now any request with a body under 50MB should succeed.
                    </p>
                    <p>
                        I am also using the helmet module which secures my API by setting certain HTTP headers on requests<sup>2</sup>.  All I have to 
                        do to activate helmet is write one line: <code>app.use(helmet({}))</code>.
                    </p>
                    <p>
                        Let’s take a look at one of these routes - the user route.  The first thing to look at is the user model which is defined using 
                        Mongoose.  The model can be used to define all the properties of an object and certain validation rules such as regex matches and 
                        length requirements.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const mongoose = require('mongoose');
                                
const UserSchema = new mongoose.Schema({
    username: {
        type: String,
        trim: true,
        required: true,
        match: /^[a-zA-Z0-9]+$/,
        validate: [
            function (username) {
                return username.length <= 15;
            },
            'Username must be less than 15 characters'
        ]
    },
    first: {...},
    last: {...},
    password: {
        type: String,
        trim: true,
        required: true,
        match: /^[^\s]+$/
    },
    postCount: {
        type: Number,
        default: 0
    }
});

UserSchema.index({username: 1});

module.exports = mongoose.model('User', UserSchema, 'user');</code>
                        </pre>
                    </figure>
                    <p>
                        The <code>UserSchema</code> defines five properties - <code>username</code>, <code>first</code>, <code>last</code>, <code>password</code> &amp; 
                        <code>postCount</code> - along with certain validation for each.  Mongoose even allows you to define indexes!  You can really do practically 
                        all necessary MongoDB interactions and setup from Mongoose!  Now I am ready to use this model in my <code>userRouter</code>.
                    </p>
                    <p>
                        The <code>userRouter</code> defines a CRUD API for the User model.  Here is how I have the GET request set up for all the users in the database.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const userRouter = express.Router();
                                
userRouter.route('/')
    .get((req, res) => {

        find().catch(error => res.status(500).send(error));

        async function find() {
            const users = await User.find().exec();

            res.json(users);
        }
    });</code>
                        </pre>
                    </figure>
                    <p>
                        You can see I am utilizing Mongoose 5’s support for async functions here.  It is much more concise and easy to read this way!  For more on how async 
                        functions work you can check out my 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/11-Nov/11-26-JS-Async-Function/View">discovery post</a> on the topic.
                        This code calls the Mongoose <code>find()</code> function on the <code>User</code> schema.  This function will asynchronously return all of the 
                        documents in the user collection.
                    </p>
                    <p>
                        I’ll show one more of the REST endpoints defined on the user route - this time for an HTTP DELETE request.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">userRouter.route('/:username')
    .delete(jwtUtils.checkIfAuthenticated, (req, res) => {
        
        remove().catch(error => res.status(500).send(error));

        async function remove() {
            await req.user.remove();

            // Should return null if it was successfully deleted
            const deleted = await User.findOne({username: req.user.username}).exec();

            // Call the catch() function if the user was not deleted
            if (deleted !== null) {
                throw Error('User Still Exists');
            }

            // Audit the deletion of a user
            const audit = new Audit({
                object: req.user._id,
                type: 'user',
                message: `Deleted User ${req.user.username}`,
                source: 'NodeJS MeowCat API'
            });

            await Audit.create(audit);

            res.status(204).send();
        }
    });
                            </code>
                        </pre>
                    </figure>
                    <p>
                        In this code I used three Mongoose functions, <code>remove()</code>, <code>findOne()</code>, and <code>create()</code>.  <code>remove()</code> deletes an instance of 
                        the Mongoose user schema, <code>findOne()</code> then tries to find that user to make sure it was properly deleted.  Finally I use <code>create()</code> to insert a 
                        new document in the audit collection.  This audit collection holds all the important interaction history with the database.  Let’s take a quick look at the 
                        <code>AuditSchema</code> because it is quite unique:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const AuditSchema = new Schema({
    time: {
        type: Date,
        default: Date.now(),
        expires: 604800 // Expires after a week
    },
    object: Schema.Types.ObjectId,
    type: {
        type: String,
        required: true,
        enum: ['user', 'post']
    },
    message: {
        type: String,
        required: true
    },
    source: String
}, { capped: { size: 8192, max: 100, autoIndexId: true }});

AuditSchema.index({time: 1});
AuditSchema.index({object: 1});

module.exports = mongoose.model('Audit', AuditSchema, 'audit');</code>
                        </pre>
                    </figure>
                    <p>
                        There are two important aspects of this schema.  The first is the <code>expires</code> property on the <code>time</code> and the corresponding index defined on the 
                        <code>time</code> property.  This is how you create a time-to-live (TTL) collection in Mongoose.  In MongoDB a TTL collection is one that expires its documents after a 
                        set amount of time<sup>3</sup>.  In this case the <code>audit</code> collection expires its documents after a week.  This is a similar behavior to many 
                        logging frameworks in applications.
                    </p>
                    <p>
                        The second important spect is the <code>capped</code> property at the end of the schema definition.  This defines a fixed number of 
                        documents (the <code>max</code> property) and max number of bytes (the <code>size</code> property) that are allowed in the 
                        collection<sup>4</sup>.  In my case the <code>audit</code> collection allows a maximum of 100 documents of no greater than 8192 bytes.
                    </p>
                    <p>
                        The ability to create complex MongoDB structures in Mongoose shows off the versatility of the module.  I use Mongoose with all of my user and post routes.  One important 
                        aspect of the post route is the ability to upload a picture with a cat post.  I need to store this picture as a file on the server 
                        Node.js is running on.  Let’s first look at the HTTP POST endpoint for posts, which is where I instruct Node to save the picture data as a file.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const express = require('express');
const files = require('../utils/files');
const jwtUtils = require('../utils/jwt');

const postRouter = express.Router();

postRouter.route('/')
    .post(jwtUtils.checkIfAuthenticated, (req, res) => {

        // pictureData isn't part of the Post Schema, so remove it once we assign it a variable
        const data = req.body.pictureData;
        delete req.body.pictureData;

        const post = new Post(req.body);

        if (post.picture &amp;&amp; post.name &amp;&amp; post.picture &amp;&amp; data) {

            // The naming convention for saved files is [username]_[filename].[filetype]
            post.picture = `${post.username}_${post.picture}`;

            // First save the file to the servers filesystem
            files.saveFile(post.picture, data);

            // Then insert the post into MongoDB
            insert().catch(error => res.status(500).send(error));

            async function insert() {...}
        }
    });</code>
                        </pre>
                    </figure>
                    <p>
                        This endpoint extracts the picture data from the HTTP request body and sends it to the function <code>saveFile()</code>.  
                        The arguments for this function are the base 64 encoded picture data and the file name.  Let’s take a look at that function now: 
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const fs = require('fs');
const path = require('path');

exports.saveFile = function saveFile(name, data) {
                                
    // Replace the start of the base 64 encoding - this is not the actual picture file data
    const base64 = data.replace(/^data:image\/([a-z]+);base64,/, "");

    fs.writeFile(path.join(__dirname, `../pics/${name}`), base64, 'base64', (err) => {
        console.error(err);
    });
};</code>
                        </pre>
                    </figure>
                    <p>
                        The imported <code>fs</code> module allows for interaction with the filesystem.  I use the <code>writeFile()</code> function to 
                        create a new file in the filesystem with the base 64 encoded picture data.
                    </p>
                    <p>
                        Besides for adding a new file when uploading a post, I also delete the file when no more posts reference it.  You can check out 
                        all of the file manipulation functions I created in 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/src/utils/files.js">files.js</a> 
                        and all the endpoints that use the file manipulation functions in 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/src/route/postRouter.js">postRouter.js</a>.
                    </p>
                    <p>
                        You may have also noticed that I passed the <code>post()</code> function in the <code>postRouter</code> the argument 
                        <code>jwtUtils.checkIfAuthenticated</code>.  This is a function that I use for authentication.  Certain endpoints in my REST API 
                        require the user to be authenticated, such as deleting a user or creating a new post.  When a user logs in, they go through the 
                        <code>authRouter</code> and get an authentication token.  This token will then be included on all further HTTP requests.  I used 
                        JSON Web Tokens (JWT) for authentication in my application.  JWT’s are a huge topic in itself, and I made a 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/03-Mar/3-11-JWT/View/jwt.html">discovery</a> about some of 
                        the basic concepts.  I also include the code in this prototype, so check it out if you want more details!
                    </p>
                    <h5>Webpack Not In the Web?</h5>
                    <p>
                        The MEAN Stack prototype was also my first experience with Webpack!  While Angular CLI is built on top of Webpack, you don't actually 
                        have to interact with the underlying Webpack config files to use it.  The Node.js server was my first actual time configuring Webpack 
                        to bundle an application!
                    </p>
                    <p>
                        Webpack is a module bundler commonly used with JavaScript projects, especially those used in the browser<sup>5</sup>.  It builds a 
                        dependency graph of your projects modules and then bundles them into a few larger files.  The reason for bundling JavaScript files is 
                        that HTTP requests from the web browser to the server are expensive.  If you bundled your JavaScript files into a smaller number of 
                        files, it would reduce the number of HTTP requests, speeding up the web application.  There is much more complexity to Webpack that 
                        deserves many discovery posts of its own, but that is the basic idea!
                    </p>
                    <p>
                        While Webpack is mostly used in the front-end, there is nothing from stopping you from using it with Node.js.  You can change the 
                        environment that Webpack runs in with the <code>target</code> field used in the Webpack configuration<sup>6</sup>.  Let’s take a look 
                        at the Webpack configuration file 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/src/webpack.config.js">webpack.config.js</a> 
                        used in my Node.js/Express server:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">module.exports = {
    entry: [
        'babel-polyfill',
        './src/app'
    ],
    target: "node",
    node: {
        __dirname: false,
        __filename: false
    },
    module: {
        rules: [{
            test: /\.js?$/,
            use: "babel-loader",
            exclude: /node_modules/
        }]
    },
    output: {
        path: path.join(__dirname, '../build'),
        filename: "app.js"
    }
};</code>
                        </pre>
                    </figure>
                    <p>
                        I will quickly run through what this configuration does.  First it declares two entry points for web pack to start building its dependency graph.  
                        The entry <code>babel-polyfill</code> is necessary to use those wonderful async functions seen in my routes.  I then set the target 
                        environment to node.  The <code>node</code> field is necessary because of a bug where the variable <code>__dirname</code> contains 
                        the incorrect value after being bundled with Webpack<sup>7</sup>.
                    </p>
                    <p>
                        The <code>module</code> field defines Webpack loaders.  Loaders perform transformations on the files during the bundling process.  
                        The loader used here is for Babel, a compiler that will transpile ES6+ JavaScript code into ES5.  While less important on the server 
                        side since newest versions of Node.js support the newest JavaScript features, transpiling into ES5 gives much greater browser 
                        compatibility for a web application.  I did a full discovery on 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/11-Nov/11-10-ES6-Modules-Babel/View/modules-babel.html">Babel</a> 
                        as well!
                    </p>
                    <p>
                        Back to the Webpack config for the <code>babel-loader</code>.  The regex defined in the <code>test</code> property tells Webpack to 
                        only use the <code>babel-loader</code> on files with the JavaScript extension.  The other regex defined in the <code>exclude</code> 
                        property tells Webpack to not run this loader on the projects module dependencies in the <code>node_modules</code> folder. 
                    </p>
                    <p>
                        Finally, the <code>output</code> property defines where the completed bundle will be located.  I tell Webpack to put it in the build 
                        directory with the name app.js.  And just like that, the Webpack config for the server application is completed!
                    </p>
                    <p>
                        I defined an npm script to start Webpack with this configuration in the projects 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/package.json">package.json</a> file.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-json" title="JSON" contenteditable="true" spellcheck="false">...
"scripts": {
    "start:dev": "webpack-node-dev --config src/webpack.config.js"
},
...</code>
                        </pre>
                    </figure>
                    <p>
                        While the server side app doesn't really require bundling, it was a really good experience to start using Webpack.  Also the 
                        configuration on the server side is much simpler than it would be on the front-end, so it was great for a beginner.  I am excited to 
                        use Webpack with my upcoming React prototype!
                    </p>
                    <h5>Unit Tests and CI</h5>
                    <p>
                        The MEAN Stack prototype was the first project I made with Continuous Integration (CI).  With CI you integrate your code into 
                        the main repository on every commit.  With this approach unit tests get run every time new code is submitted.  This allows for 
                        constant regression testing and makes it easier to catch bugs early on.  I wrote a whole discovery about using TravisCI for 
                        my CI in this project!  It really was a game changer, and I will use it in my projects from now on!
                    </p>
                    <p>
                        With CI it is important to have good tests.  I have always had a bad habit of slacking on writing test code.  While I didn't 
                        completely break this bad habit with the MEAN prototype, I did write some test code for my REST endpoints!
                    </p>
                    <p>
                        I looked at one of my tests in my TravisCI discovery, but lets look quickly at two other test suites here.  I used the supertest 
                        npm module for testing HTTP requests along with the mocha test framework.  Supertest was a really nice API that made testing my 
                        endpoints easy!  Here is the testing suite for my main app endpoint:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const request = require('supertest');
const app = require('../src/app');

// Tests for the default endpoint '/'
describe("GET '/'", () => {
    it('responded with a 200', () => {
        return request(app).get('/').expect(200);
    });

    it("returned correct JSON", () => {
        return request(app)
            .get('/')
            .expect('Content-Type', /json/)
            .expect(200)
            .expect('Content-Length', '36');
    });

    it("Uses Helmet", () => {
        return request(app)
            .get('/files')
            .expect('X-Content-Type-Options', 'nosniff')
            .expect('X-DNS-Prefetch-Control', 'off')
            .expect('X-Download-Options', 'noopen')
            .expect('X-Frame-Options', 'SAMEORIGIN')
            .expect('X-XSS-Protection', '1; mode=block')
    });
});</code>
                        </pre>
                    </figure>
                    <p>
                        In the mocha testing framework <code>describe()</code> defines a testing group and <code>it()</code> defines a test 
                        case<sup>8</sup>.  You can see in the code above I defined a testing group with three test cases.  The first test 
                        case simply checks to see if the endpoint returns an HTTP 200 OK status.  I use the supertest <code>get()</code> 
                        function to make a GET request to the endpoint given as an argument and <code>expect()</code> to define the 
                        anticipated HTTP response.
                    </p>
                    <p>
                        The second and third test cases also use these basic building blocks.  I chain <code>expect()</code> functions to 
                        define multiple anticipated responses.  The second test checks to see that the returned content type is JSON and 
                        is of a certain length.  The last test case makes sure that the helmet module discussed earlier is properly adding 
                        certain HTTP headers.  You can see with these tests how easy it is to create some HTTP endpoint tests with 
                        supertest and mocha!
                    </p>
                    <p>
                        I defined one more test suite for the posts endpoints in 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/test/postRouter.test.js">postRouter.test.js</a>.  
                        In that test case I make sure an 
                        endpoint that requires a JWT for use returns a 401 error when no token is present on the request header.
                    </p>
                    <p>
                        That finishes up my discussion of the Node.js/Express backend for my MEAN stack prototype.  If you want to check 
                        out all the code for the Node.js backend it is available on 
                        <a href="https://github.com/AJarombek/mean-server-prototype">GitHub</a>.  
                        Whenever the Angular 
                        front-end needs data from the server it simply hits one of the REST endpoints I defined in Node.js.  Now let’s 
                        move on to the Angular frontend!  
                    </p>
                    <h5>The Angular Front-End</h5>
                    <p>
                        The frontend of the MEAN stack uses Angular.  Angular is a full fledged frontend framework, meaning that you must follow the 
                        code structure defined by the framework.  While this may give less flexibility to the developer it can also make sure the code 
                        stays structured even in the most complex of applications.  The version of the Angular framework is 5 at the time of this writing, 
                        and that is what I used in my prototype.  While you can write Angular applications in JavaScript or any language that transpiles 
                        to JavaScript, the team at Angular suggests that you use TypeScript.  TypeScript is a language developed by Microsoft that gives 
                        the option to apply strict typing on top of JavaScript.  I wrote a discovery post on 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/03-Mar/3-8-TypeScript/View/typescript.html">TypeScript</a> 
                        that goes into more details about 
                        the features of the language and what I learned/liked about it from this Angular project.
                    </p>
                    <p>
                        I also wrote a discovery post about my 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/01-Jan/1-6-Angular-5-First-Impression/View/angular-first-imp.html">first impressions</a> 
                        of the Angular framework.  In that post I was a bit critical of the 
                        framework.  While I think Angular is far from perfect, it was definitely a joy to learn and work with.  It does have its issues 
                        which I will cover in this blog.  Another note is that this blog isn't going to teach beginners how to use Angular.  I expect that 
                        you have some knowledge about the framework and how it works.  I will go through all the major components of my application as well 
                        as other cool services, directives, etc.  Let’s get started by looking at the app component.  This component is the entry point for 
                        the application and holds all the routes through the single page application (SPA).
                    </p>
                    <h5>App Component</h5>
                    <p>
                        Before we look at the app component code directly, it is important to look at some of the code in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/app.module.ts">app.module.ts</a>.  
                        This module contains all the components except those for user profiles and cat posts.  It also defines 
                        the routes for my application.  Here are these route definitions:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">export const routes: Routes = [
    {path: '', component: HomeComponent},
    {path: 'user', loadChildren: './profile/profile.module#ProfileModule'},
    {path: 'about', component: AboutComponent},
    {path: 'login', component: LoginComponent},
    {path: 'signup', component: SignupComponent},
    {path: '**', redirectTo: ''}
];</code>
                        </pre>
                    </figure>
                    <p>
                        The user route is unique because it implements lazy loading.  This means that the module containing code for that route will not be loaded 
                        from the server until we traverse the route.  I discussed 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/01-Jan/1-27-Angular-5-Routing/View/angular-routing.html">Angular lazy loading</a> 
                        in more depth in a discovery post.
                    </p>
                    <p>
                        You may be wondering why the <code>AppComponent</code> is missing in these routes?  The AppComponent is actually the root component 
                        and it is bootstrapped into the module<sup>9</sup>.  It is defined in the <code>bootstrap</code> property on the <code>@NgModule</code> 
                        definition.  On app launch the <code>AppComponent</code> will then be bootstrapped and rendered by default. 
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">@NgModule({
    ...
    bootstrap: [AppComponent]
})</code>
                        </pre>
                    </figure>
                    <p>
                        The <code>AppComponent</code> template defines the navigation bar for the website.  Clicking on this navigation bar will change the 
                        route.  Based on the routes definition code shown before, different routes will display different components on the page.  The 
                        components will be displayed in the <code>&lt;router-outlet&gt;</code> element, as discussed further in my 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/01-Jan/1-27-Angular-5-Routing/View/angular-routing.html">discovery post</a>.
                          The code for the app components template is found in 
                          <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/app.component.html">app.component.html</a>
                    </p>
                    <p>
                        The navigation bar uses both Bootstrap and Sass for the styling.  In fact, all of the website uses a combination of Bootstrap and 
                        Sass for the UI.  While I really have loved Sass and how it modularizes my stylesheets and makes them easier to read and work with.  
                        I made a discovery post about 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/03-Mar/3-10-Sass/View/sass.html">Sass</a> 
                        if you want to learn more about how I used it in this prototype.  Bootstrap on the other hand I have mixed feelings about.  While it 
                        does have really cool components like the navbar I used for this website, it also comes with many frustrations.  For one the current 
                        state of Bootstrap has been a bit of a mess.  Different versions come with completely different non-backwards compatible naming 
                        conventions.  While this is confusing, to make matters worse the documentation online is not even up to date with the current release.  
                        This made developing with Bootstrap really frustrating.
                    </p>
                    <p>
                        If this was the only issue I had with Bootstrap I would suggest to wait for it to get into a more stable state before jumping onboard.  
                        However, I also found that many of the components weren’t as customizable as I would have liked.  This makes bootstrap seem like more of 
                        a fun pet project tool than something worth using in production.  I will discuss this lack of customizability in more detail when discussing 
                        the cat picture module.
                    </p>
                    <p>
                        The <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/app.component.ts">app.component.ts</a> 
                        code also subscribes to certain services that emit and receive messages to and from child components.  This allows 
                        for message passing between components.  I will go into detail about these services one I look at the child components that subscribe 
                        to them.
                    </p>
                    <p>
                        Now I want to look at the default route of the application which displays the <code>HomeComponent</code>.
                    </p>
                    <h5>Home Page</h5>
                    <figure id="maincomponent-image">
                        <img src="main-component.png">
                    </figure>
                    <p>
                        The code in the <code>HomeComponent</code> is pretty simple.  It subscribes to a service called <code>postService</code>.  By calling 
                        the <code>getAll()</code> function in <code>postService</code> the component will get all the cat posts stored on the server.  These will 
                        then be displayed in the UI.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">import { Component } from '@angular/core';
import {PostService} from "../post.service";
import {Post} from "../models/post";
import {environment} from "../../environments/environment";

@Component({
    selector: 'app-home',
    templateUrl: './home.component.html',
    styleUrls: ['./home.component.scss']
})
export class HomeComponent {
    posts: [Post];

    // The private modifier creates a new instance variable
    constructor(private postService: PostService) {

    // When the Observable getAll() value returns give it to the posts variable
    postService.getAll().subscribe(data => {

        this.posts = data;

        // Different behavior depending on environment
        if (environment.evt === 'dev') {
            this.posts.forEach(post => {
                post.date = new Date(post.date);
                post.picture = `${post.picture}`;
            });
        }
    });
    }
}</code>
                        </pre>
                    </figure>
                    <p>
                        The <code>postService</code> is one of the many services I created for this project.  It makes HTTP requests to the posts API.  
                        Here is a look at the service:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">import {Injectable} from '@angular/core';
import {Post} from "./models/post";
import {HttpClient} from "@angular/common/http";
import {Observable} from "rxjs/Observable";
import {HttpService} from "./http.service";

@Injectable()
export class PostService implements HttpService {

    constructor(private http: HttpClient) {}

    getAll(): Observable<[any]> {
        return this.http.get<[Post]>(`/api/post`);
    }

    get(id: number): Observable<any> {
        return this.http.get<Post>(`/api/post/${id}`);
    }

    post(post: Post): Observable<any> {
        return this.http.post<Post>(`/api/post`, post);
    }

    put(post: Post): Observable<any> {
        return this.http.put<Post>(`/api/post/${post.id}`, post);
    }

    delete(id: number): Observable<any> {
        return this.http.delete<any>(`/api/post/${id}`);
    }
}</code>
                        </pre>
                    </figure>
                    <p>
                        Each function in the service corresponds with a route defined in the Node.js <code>postRouter</code> API.  You can also see that the 
                        service implements a TypeScript interface.  The code for this interface is found in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/http.service.ts">http.service.ts</a>.  
                        I defined this interface to be implemented in all my HTTP request services.
                    </p>
                    <p>
                        The HTML template for the <code>HomeComponent</code> loops through the <code>posts</code> array and passes each post to the 
                        <code>CatPictureComponent</code>.  This component will display the cat post on the UI.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-html" title="HTML" contenteditable="true" spellcheck="false">&lt;div id="home-container" class="container-fluid mt-3"&gt;
    &lt;!-- Go through all the cat posts and pass each post to the cat-picture component --&gt;
    &lt;div class="card-columns"&gt;
        &lt;div *ngFor="let post of posts"&gt;
        &lt;cat-picture [post]="post"&gt;&lt;/cat-picture&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code>
                        </pre>
                    </figure>
                    <h5>Cat Posts</h5>
                    <h5>Login Page</h5>
                    <h5>Signup Page</h5>
                    <h5>Profile Page</h5>
                    <h5>Post Page</h5>
                    <h5>About Page</h5>
                    <h5>Unit Testing Angular</h5>
                    <h5>Dealing with Multiple Environments</h5>
                    <h5>Future Steps</h5>
                    <h5>Conclusions</h5>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false"></code>
                        </pre>
                    </figure>
                    <figure>
                        <pre class="command-line" data-prompt="$">
                            <code class="language-bash" title="Bash" contenteditable="true" spellcheck="false"></code>
                        </pre>
                    </figure>
                    <p>
                        The code for the prototype is available on my 
                        <a href="https://github.com/AJarombek/nodejs-mongodb-api-prototype">GitHub</a>. 
                    </p>
                    <div class="container tags">
                        <p>
                            Tags: <span class="badge badge-default">Angular</span> <span class="badge badge-default">Sass</span> <span class="badge badge-default">HTML</span>
                            <span class="badge badge-default">Bootstrap</span> <span class="badge badge-default">JWT</span> <span class="badge badge-default">TravisCI</span>
                            <span class="badge badge-default">MongoDB</span> <span class="badge badge-default">Node.js</span> <span class="badge badge-default">Express</span>
                            <span class="badge badge-default">JavaScript</span> <span class="badge badge-default">ECMAScript 6</span> <span class="badge badge-default">NoSQL</span> <span class="badge badge-default">Document Database</span>
                            <span class="badge badge-default">Mongoose</span> <span class="badge badge-default">TypeScript</span> <span class="badge badge-default">Webpack</span> <span class="badge badge-default">REST</span>
                        </p>
                    </div>
                    <div class="container sources">
                        <p>[1] "Introducing Mongoose 5.0.0-rc0", http://thecodebarbarian.com/introducing-mongoose-5.html</p>
                        <p>[2] "Helmet", https://helmetjs.github.io/</p>
                        <p>[3] Kyle Banker, Peter Bakkum, Shaun Verch, Douglas Garrett &amp; Tom Hawkins, MongoDB In Action, 2nd ed (Shelter Island, NY: Manning, 2016), 89</p>
                        <p>[4] Banker., 90</p>
                        <p>[5] Juho Vepsäläinen, SurviveJS: Webpack, (2017), xi</p>
                        <p>[6] Vepsäläinen., 259</p>
                        <p>[7] "__dirname returns '/' when js file is built with webpack", https://github.com/webpack/webpack/issues/1599</p>
                        <p>[8] "A guide to mocha's describe(), it() and setup hooks", https://samwize.com/2014/02/08/a-guide-to-mochas-describe-it-and-setup-hooks/</p>
                        <p>[9] Yakov Fain &amp; Anton Moiseev, Angular 2 Development with TypeScript (Shelter Island, NY: Manning, 2017), 33</p>
                    </div>
                </div>
            </div>
        </div>
        <script src="../../../prism.js"></script>
    </body>
</html>