<!DOCTYPE html>
<!-- Author: Andrew Jarombek
     Date: 12/12/2017 -->
<html>
    <head>
        <meta chartset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Creating a MEAN Stack Prototype</title>
        <link rel="stylesheet" href="../../../blog-discover.css">
        <link rel="stylesheet" href="style/mean-stack.css">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/fantasque-sans-mono" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" 
            integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
        <link href="../../../prism.css" rel="stylesheet" />
    </head>
    <body>
        <div class="col-md-12 discoveryBody">
            <div class="col-md-12 discoveryContent">
                <p class="date">March 17th, 2018</p>
                <br>
                <h4>Creating a MEAN Stack Prototype</h4>
                <br>
                <div class="container aknowledge">
                    <p>Assumed Knowledge:</p>
                    <p>Angular <span class="badge badge-warning">Intermediate</span></p>
                    <p>Node.js <span class="badge badge-warning">Intermediate</span></p>
                    <p>Express <span class="badge badge-warning">Intermediate</span></p>
                    <p>MongoDB <span class="badge badge-warning">Intermediate</span></p>
                    <p>JavaScript <span class="badge badge-warning">Intermediate</span></p>
                    <p>TypeScript <span class="badge badge-warning">Intermediate</span></p>
                    <p>HTML <span class="badge badge-default">Basic</span></p>
                    <p>REST <span class="badge badge-default">Basic</span></p>
                </div><br>
                <div id="discoveryText" class="container">
                    <p>
                        Much of my work lately has been in preparation for a personal website that I am going to build (and where this blog post 
                        will call home!).  The website is going to contain my resume, blog posts, discovery posts, and more.  I am really excited 
                        to get started building it!
                    </p>
                    <p>
                        The first order of business however is to decide which technology stack I want to use for the website.  I have narrowed it 
                        down to a full JavaScript stack, from the front-end through the database.  There are two remaining tech stacks in competition: 
                        the MEAN stack (MongoDB, Express, Angular, &amp; Node.js) and the MERN stack (MongoDB, Express, React.js &amp; Node.js).  I started 
                        the journey of deciding by reading many JavaScript books and writing plenty of discovery posts about them.  I also explored Node.js 
                        and MongoDB in depth.  I even made a 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Blogs/2017/12-30-NodeJS-MongoDB-API-Prototype">blog post</a> and 
                        <a href="https://github.com/AJarombek/nodejs-mongodb-api-prototype">prototype</a>
                         on both the technologies!  Now it is time to pick between the two front 
                        end JavaScript frameworks: Angular by Google and React.js by Facebook.  
                    </p>
                    <p>
                        This blog post is my journey through creating a prototype with Angular.  I will look at the prototype at a higher level and deep dive 
                        into code that makes the website function.  All along the way I will give my thoughts about Angular and all the other technologies that 
                        I learned along the way.  I will conclude with my current thoughts on Angular and what I feel React.js needs to bring to the table to 
                        defeat it!
                    </p>
                    <p>
                        I had a lot of fun (for the most part!) building with Angular, so let’s get started!
                    </p>
                    <h5>The Prototype</h5>
                    <p>
                        The MEAN stack prototype was a website that allows its users to upload cat pictures!  Appropriately, the website is named MeowPics.
                    </p>
                    <figure id="meowcat-image">
                        <img src="meowcat.png">
                    </figure>
                    <p>
                        The MongoDB, Express, Angular, and Node.js technology stack works as follows:
                    </p>
                    <figure id="meanstack-image">
                        <img src="MEAN-Stack.png">
                    </figure>
                    <p>
                        The first piece of the technology stack for MeowPics that I will walkthrough is the MongoDB document database.
                    </p>
                    <h5>MongoDB Structure</h5>
                    <p>
                        I have 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/12-Dec/12-15-MongoDB-Pt1">written</a> 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/12-Dec/12-16-MongoDB-Pt2">many</a> 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/12-Dec/12-23-MongoDB-Pt3">discovery</a> 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/12-Dec/12-27-MongoDB-Pt4">posts</a> on MongoDB in the past, but in general terms it is a NoSQL document database that stores data in collections 
                        of objects.  I used it extensively in my Node.js and MongoDB prototype as well.  The biggest reason I want to use MongoDB in my website is that 
                        it fits the JavaScript web stack since its queries are in JavaScript and objects are BSON (Binary JSON).
                    </p>
                    <p>
                        The MongoDB database for MeowPics has two main collections for users and cat posts.  There is also an audit collection that is used for logging 
                        purposes when updates, inserts, or deletions are made to documents in the user or post collections.
                    </p>
                    <p>
                        Here are some insert statements that show the structure of the user and post collections:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">db.user.insertMany([
    {
        username: "andy",
        first: "Andrew",
        last: "Jarombek",
        password: "$2a$10$c/DwED6TayK0d3ce5761zOTBBsnCB.JMpcF4l4Zojqti6Adaym9W2",
        postCount: 4
    },
    {
        username: "tom",
        first: "Thomas",
        last: "Caulfield",
        password: "$2a$10$8Irw8CAvdJr2uBAUYdlinOf8T9dblJiz0mumgNyfiHGBmT9vUweo6",
        postCount: 2
    }
]);

let andy_id = db.user.findOne({username: "andy"})._id;
let tom_id = db.user.findOne({username: "tom"})._id;
    
db.post.insertMany([
    {
        picture: "russianblue.jpg",
        name: "Cat Pic",
        username: "andy",
        user_id: andy_id,
        first: "Andrew",
        last: "Jarombek",
        date: new Date("2018-02-26"),
        description: "I love this picture!",
        up: 1,
        down: 0
    },
    {
        picture: "toms-cat.jpg",
        name: "Kitty!",
        username: "tom",
        user_id: tom_id,
        first: "Thomas",
        last: "Caulfield",
        date: new Date("2018-02-24"),
        description: "awww!",
        up: 5,
        down: 1
    }
]);</code>
                        </pre>
                    </figure>
                    <p>
                        While these statements are performed on the MongoDB database directly, most of my interactions were done through Mongoose.  
                        Mongoose is a Node.js module that allows you to model objects from MongoDB as well as performing queries, inserts, updates 
                        and more.  It is a really powerful tool that I used in my Node.js and MongoDB prototype.  For that prototype I was using 
                        version 4 of Mongoose.  I was really excited to see that in early January Mongoose 5 was released, which took big steps by 
                        using Promises by default and support for async functions<sup>1</sup>!  Let’s take a look at Mongoose 5 and the rest of 
                        the Node.js/Express API.
                    </p>
                    <h5>Node.js REST API</h5>
                    <p>
                        The Node.js/Express API defines three main routes and one for developer testing.  The three main routes are for users, 
                        posts, and authentication.  The users and posts routes define a CRUD API for both corresponding MongoDB collections.  Here is 
                        the entry point code to the server application:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const helmet = require('helmet');

const Post = require('./model/post');
const User = require('./model/user');
const Test = require('./model/test');
const Audit = require('./model/audit');

const userRouter = require('./route/userRouter')(User, Audit);
const postRouter = require('./route/postRouter')(Post, User, Audit);
const authRouter = require('./route/authRouter')(User);
const testRouter = require('./route/testRouter')(Test);

// Mongoose 5.0 uses native JS Promises by default (less config needed!)
mongoose.connect('mongodb://127.0.0.1/meowcat');

const app = express();

// Set a larger payload limit for HTTP requests since some image data will be large
app.use(bodyParser.urlencoded({extended: true, limit: '50mb'}));
app.use(bodyParser.json({limit: '50mb'}));

// Helps protect our API endpoint from well known web security vulnerabilities
app.use(helmet({}));

const port = process.env.port || 3000;

app.use('/api/test', testRouter);
app.use('/api/user', userRouter);
app.use('/api/post', postRouter);
app.use('/api/auth', authRouter);

app.get('/', (req, res) => {
    res.send(JSON.parse('{"title":"Welcome to the Apps API!"}'));
});

module.exports = app.listen(port, () => {
    console.info(`Started MeowCat API on port ${port}`);
});</code>
                        </pre>
                    </figure>
                    <p>
                        If you have seen an Express application before this should look familiar.  Some important points are that we are using Mongoose 
                        5, which requires less startup configuration.  I also had to set the <code>limit</code> property for <code>bodyParser</code> 
                        because the client may be sending large cat images to the server.  Now any request with a body under 50MB should succeed.
                    </p>
                    <p>
                        I am also using the helmet module which secures my API by setting certain HTTP headers on requests<sup>2</sup>.  All I have to 
                        do to activate helmet is write one line: <code>app.use(helmet({}))</code>.
                    </p>
                    <p>
                        Let’s take a look at one of these routes - the user route.  The first thing to look at is the user model which is defined using 
                        Mongoose.  The model can be used to define all the properties of an object and certain validation rules such as regex matches and 
                        length requirements.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const mongoose = require('mongoose');
                                
const UserSchema = new mongoose.Schema({
    username: {
        type: String,
        trim: true,
        required: true,
        match: /^[a-zA-Z0-9]+$/,
        validate: [
            function (username) {
                return username.length <= 15;
            },
            'Username must be less than 15 characters'
        ]
    },
    first: {...},
    last: {...},
    password: {
        type: String,
        trim: true,
        required: true,
        match: /^[^\s]+$/
    },
    postCount: {
        type: Number,
        default: 0
    }
});

UserSchema.index({username: 1});

module.exports = mongoose.model('User', UserSchema, 'user');</code>
                        </pre>
                    </figure>
                    <p>
                        The <code>UserSchema</code> defines five properties - <code>username</code>, <code>first</code>, <code>last</code>, <code>password</code> &amp; 
                        <code>postCount</code> - along with certain validation for each.  Mongoose even allows you to define indexes!  You can really do practically 
                        all necessary MongoDB interactions and setup from Mongoose!  Now I am ready to use this model in my <code>userRouter</code>.
                    </p>
                    <p>
                        The <code>userRouter</code> defines a CRUD API for the User model.  Here is how I have the GET request set up for all the users in the database.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const userRouter = express.Router();
                                
userRouter.route('/')
    .get((req, res) => {

        find().catch(error => res.status(500).send(error));

        async function find() {
            const users = await User.find().exec();

            res.json(users);
        }
    });</code>
                        </pre>
                    </figure>
                    <p>
                        You can see I am utilizing Mongoose 5’s support for async functions here.  It is much more concise and easy to read this way!  For more on how async 
                        functions work you can check out my 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/tree/master/Discoveries/2017/11-Nov/11-26-JS-Async-Function/View">discovery post</a> on the topic.
                        This code calls the Mongoose <code>find()</code> function on the <code>User</code> schema.  This function will asynchronously return all of the 
                        documents in the user collection.
                    </p>
                    <p>
                        I’ll show one more of the REST endpoints defined on the user route - this time for an HTTP DELETE request.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">userRouter.route('/:username')
    .delete(jwtUtils.checkIfAuthenticated, (req, res) => {
        
        remove().catch(error => res.status(500).send(error));

        async function remove() {
            await req.user.remove();

            // Should return null if it was successfully deleted
            const deleted = await User.findOne({username: req.user.username}).exec();

            // Call the catch() function if the user was not deleted
            if (deleted !== null) {
                throw Error('User Still Exists');
            }

            // Audit the deletion of a user
            const audit = new Audit({
                object: req.user._id,
                type: 'user',
                message: `Deleted User ${req.user.username}`,
                source: 'NodeJS MeowCat API'
            });

            await Audit.create(audit);

            res.status(204).send();
        }
    });
                            </code>
                        </pre>
                    </figure>
                    <p>
                        In this code I used three Mongoose functions, <code>remove()</code>, <code>findOne()</code>, and <code>create()</code>.  <code>remove()</code> deletes an instance of 
                        the Mongoose user schema, <code>findOne()</code> then tries to find that user to make sure it was properly deleted.  Finally I use <code>create()</code> to insert a 
                        new document in the audit collection.  This audit collection holds all the important interaction history with the database.  Let’s take a quick look at the 
                        <code>AuditSchema</code> because it is quite unique:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const AuditSchema = new Schema({
    time: {
        type: Date,
        default: Date.now(),
        expires: 604800 // Expires after a week
    },
    object: Schema.Types.ObjectId,
    type: {
        type: String,
        required: true,
        enum: ['user', 'post']
    },
    message: {
        type: String,
        required: true
    },
    source: String
}, { capped: { size: 8192, max: 100, autoIndexId: true }});

AuditSchema.index({time: 1});
AuditSchema.index({object: 1});

module.exports = mongoose.model('Audit', AuditSchema, 'audit');</code>
                        </pre>
                    </figure>
                    <p>
                        There are two important aspects of this schema.  The first is the <code>expires</code> property on the <code>time</code> and the corresponding index defined on the 
                        <code>time</code> property.  This is how you create a time-to-live (TTL) collection in Mongoose.  In MongoDB a TTL collection is one that expires its documents after a 
                        set amount of time<sup>3</sup>.  In this case the <code>audit</code> collection expires its documents after a week.  This is a similar behavior to many 
                        logging frameworks in applications.
                    </p>
                    <p>
                        The second important spect is the <code>capped</code> property at the end of the schema definition.  This defines a fixed number of 
                        documents (the <code>max</code> property) and max number of bytes (the <code>size</code> property) that are allowed in the 
                        collection<sup>4</sup>.  In my case the <code>audit</code> collection allows a maximum of 100 documents of no greater than 8192 bytes.
                    </p>
                    <p>
                        The ability to create complex MongoDB structures in Mongoose shows off the versatility of the module.  I use Mongoose with all of my user and post routes.  One important 
                        aspect of the post route is the ability to upload a picture with a cat post.  I need to store this picture as a file on the server 
                        Node.js is running on.  Let’s first look at the HTTP POST endpoint for posts, which is where I instruct Node to save the picture data as a file.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const express = require('express');
const files = require('../utils/files');
const jwtUtils = require('../utils/jwt');

const postRouter = express.Router();

postRouter.route('/')
    .post(jwtUtils.checkIfAuthenticated, (req, res) => {

        // pictureData isn't part of the Post Schema, so remove it once we assign it a variable
        const data = req.body.pictureData;
        delete req.body.pictureData;

        const post = new Post(req.body);

        if (post.picture &amp;&amp; post.name &amp;&amp; post.picture &amp;&amp; data) {

            // The naming convention for saved files is [username]_[filename].[filetype]
            post.picture = `${post.username}_${post.picture}`;

            // First save the file to the servers filesystem
            files.saveFile(post.picture, data);

            // Then insert the post into MongoDB
            insert().catch(error => res.status(500).send(error));

            async function insert() {...}
        }
    });</code>
                        </pre>
                    </figure>
                    <p>
                        This endpoint extracts the picture data from the HTTP request body and sends it to the function <code>saveFile()</code>.  
                        The arguments for this function are the base 64 encoded picture data and the file name.  Let’s take a look at that function now: 
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const fs = require('fs');
const path = require('path');

exports.saveFile = function saveFile(name, data) {
                                
    // Replace the start of the base 64 encoding - this is not the actual picture file data
    const base64 = data.replace(/^data:image\/([a-z]+);base64,/, "");

    fs.writeFile(path.join(__dirname, `../pics/${name}`), base64, 'base64', (err) => {
        console.error(err);
    });
};</code>
                        </pre>
                    </figure>
                    <p>
                        The imported <code>fs</code> module allows for interaction with the filesystem.  I use the <code>writeFile()</code> function to 
                        create a new file in the filesystem with the base 64 encoded picture data.
                    </p>
                    <p>
                        Besides for adding a new file when uploading a post, I also delete the file when no more posts reference it.  You can check out 
                        all of the file manipulation functions I created in 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/src/utils/files.js">files.js</a> 
                        and all the endpoints that use the file manipulation functions in 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/src/route/postRouter.js">postRouter.js</a>.
                    </p>
                    <p>
                        You may have also noticed that I passed the <code>post()</code> function in the <code>postRouter</code> the argument 
                        <code>jwtUtils.checkIfAuthenticated</code>.  This is a function that I use for authentication.  Certain endpoints in my REST API 
                        require the user to be authenticated, such as deleting a user or creating a new post.  When a user logs in, they go through the 
                        <code>authRouter</code> and get an authentication token.  This token will then be included on all further HTTP requests.  I used 
                        JSON Web Tokens (JWT) for authentication in my application.  JWT’s are a huge topic in itself, and I made a 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/03-Mar/3-11-JWT/View/jwt.html">discovery</a> about some of 
                        the basic concepts.  I also include the code in this prototype, so check it out if you want more details!
                    </p>
                    <h5>Webpack Not In the Web?</h5>
                    <p>
                        The MEAN Stack prototype was also my first experience with Webpack!  While Angular CLI is built on top of Webpack, you don't actually 
                        have to interact with the underlying Webpack config files to use it.  The Node.js server was my first actual time configuring Webpack 
                        to bundle an application!
                    </p>
                    <p>
                        Webpack is a module bundler commonly used with JavaScript projects, especially those used in the browser<sup>5</sup>.  It builds a 
                        dependency graph of your projects modules and then bundles them into a few larger files.  The reason for bundling JavaScript files is 
                        that HTTP requests from the web browser to the server are expensive.  If you bundled your JavaScript files into a smaller number of 
                        files, it would reduce the number of HTTP requests, speeding up the web application.  There is much more complexity to Webpack that 
                        deserves many discovery posts of its own, but that is the basic idea!
                    </p>
                    <p>
                        While Webpack is mostly used in the front-end, there is nothing from stopping you from using it with Node.js.  You can change the 
                        environment that Webpack runs in with the <code>target</code> field used in the Webpack configuration<sup>6</sup>.  Let’s take a look 
                        at the Webpack configuration file 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/src/webpack.config.js">webpack.config.js</a> 
                        used in my Node.js/Express server:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">module.exports = {
    entry: [
        'babel-polyfill',
        './src/app'
    ],
    target: "node",
    node: {
        __dirname: false,
        __filename: false
    },
    module: {
        rules: [{
            test: /\.js?$/,
            use: "babel-loader",
            exclude: /node_modules/
        }]
    },
    output: {
        path: path.join(__dirname, '../build'),
        filename: "app.js"
    }
};</code>
                        </pre>
                    </figure>
                    <p>
                        I will quickly run through what this configuration does.  First it declares two entry points for web pack to start building its dependency graph.  
                        The entry <code>babel-polyfill</code> is necessary to use those wonderful async functions seen in my routes.  I then set the target 
                        environment to node.  The <code>node</code> field is necessary because of a bug where the variable <code>__dirname</code> contains 
                        the incorrect value after being bundled with Webpack<sup>7</sup>.
                    </p>
                    <p>
                        The <code>module</code> field defines Webpack loaders.  Loaders perform transformations on the files during the bundling process.  
                        The loader used here is for Babel, a compiler that will transpile ES6+ JavaScript code into ES5.  While less important on the server 
                        side since newest versions of Node.js support the newest JavaScript features, transpiling into ES5 gives much greater browser 
                        compatibility for a web application.  I did a full discovery on 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/11-Nov/11-10-ES6-Modules-Babel/View/modules-babel.html">Babel</a> 
                        as well!
                    </p>
                    <p>
                        Back to the Webpack config for the <code>babel-loader</code>.  The regex defined in the <code>test</code> property tells Webpack to 
                        only use the <code>babel-loader</code> on files with the JavaScript extension.  The other regex defined in the <code>exclude</code> 
                        property tells Webpack to not run this loader on the projects module dependencies in the <code>node_modules</code> folder. 
                    </p>
                    <p>
                        Finally, the <code>output</code> property defines where the completed bundle will be located.  I tell Webpack to put it in the build 
                        directory with the name app.js.  And just like that, the Webpack config for the server application is completed!
                    </p>
                    <p>
                        I defined an npm script to start Webpack with this configuration in the projects 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/package.json">package.json</a> file.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-json" title="JSON" contenteditable="true" spellcheck="false">...
"scripts": {
    "start:dev": "webpack-node-dev --config src/webpack.config.js"
},
...</code>
                        </pre>
                    </figure>
                    <p>
                        While the server side app doesn't really require bundling, it was a really good experience to start using Webpack.  Also the 
                        configuration on the server side is much simpler than it would be on the front-end, so it was great for a beginner.  I am excited to 
                        use Webpack with my upcoming React prototype!
                    </p>
                    <h5>Unit Tests and CI</h5>
                    <p>
                        The MEAN Stack prototype was the first project I made with Continuous Integration (CI).  With CI you integrate your code into 
                        the main repository on every commit.  With this approach unit tests get run every time new code is submitted.  This allows for 
                        constant regression testing and makes it easier to catch bugs early on.  I wrote a whole discovery about using TravisCI for 
                        my CI in this project!  It really was a game changer, and I will use it in my projects from now on!
                    </p>
                    <p>
                        With CI it is important to have good tests.  I have always had a bad habit of slacking on writing test code.  While I didn't 
                        completely break this bad habit with the MEAN prototype, I did write some test code for my REST endpoints!
                    </p>
                    <p>
                        I looked at one of my tests in my TravisCI discovery, but lets look quickly at two other test suites here.  I used the supertest 
                        npm module for testing HTTP requests along with the mocha test framework.  Supertest was a really nice API that made testing my 
                        endpoints easy!  Here is the testing suite for my main app endpoint:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-javascript" title="JavaScript" contenteditable="true" spellcheck="false">const request = require('supertest');
const app = require('../src/app');

// Tests for the default endpoint '/'
describe("GET '/'", () => {
    it('responded with a 200', () => {
        return request(app).get('/').expect(200);
    });

    it("returned correct JSON", () => {
        return request(app)
            .get('/')
            .expect('Content-Type', /json/)
            .expect(200)
            .expect('Content-Length', '36');
    });

    it("Uses Helmet", () => {
        return request(app)
            .get('/files')
            .expect('X-Content-Type-Options', 'nosniff')
            .expect('X-DNS-Prefetch-Control', 'off')
            .expect('X-Download-Options', 'noopen')
            .expect('X-Frame-Options', 'SAMEORIGIN')
            .expect('X-XSS-Protection', '1; mode=block')
    });
});</code>
                        </pre>
                    </figure>
                    <p>
                        In the mocha testing framework <code>describe()</code> defines a testing group and <code>it()</code> defines a test 
                        case<sup>8</sup>.  You can see in the code above I defined a testing group with three test cases.  The first test 
                        case simply checks to see if the endpoint returns an HTTP 200 OK status.  I use the supertest <code>get()</code> 
                        function to make a GET request to the endpoint given as an argument and <code>expect()</code> to define the 
                        anticipated HTTP response.
                    </p>
                    <p>
                        The second and third test cases also use these basic building blocks.  I chain <code>expect()</code> functions to 
                        define multiple anticipated responses.  The second test checks to see that the returned content type is JSON and 
                        is of a certain length.  The last test case makes sure that the helmet module discussed earlier is properly adding 
                        certain HTTP headers.  You can see with these tests how easy it is to create some HTTP endpoint tests with 
                        supertest and mocha!
                    </p>
                    <p>
                        I defined one more test suite for the posts endpoints in 
                        <a href="https://github.com/AJarombek/mean-server-prototype/blob/master/test/postRouter.test.js">postRouter.test.js</a>.  
                        In that test case I make sure an 
                        endpoint that requires a JWT for use returns a 401 error when no token is present on the request header.
                    </p>
                    <p>
                        That finishes up my discussion of the Node.js/Express backend for my MEAN stack prototype.  If you want to check 
                        out all the code for the Node.js backend it is available on 
                        <a href="https://github.com/AJarombek/mean-server-prototype">GitHub</a>.  
                        Whenever the Angular 
                        front-end needs data from the server it simply hits one of the REST endpoints I defined in Node.js.  Now let’s 
                        move on to the Angular frontend!  
                    </p>
                    <h5>The Angular Front-End</h5>
                    <p>
                        The frontend of the MEAN stack uses Angular.  Angular is a full fledged frontend framework, meaning that you must follow the 
                        code structure defined by the framework.  While this may give less flexibility to the developer it can also make sure the code 
                        stays structured even in the most complex of applications.  The version of the Angular framework is 5 at the time of this writing, 
                        and that is what I used in my prototype.  While you can write Angular applications in JavaScript or any language that transpiles 
                        to JavaScript, the team at Angular suggests that you use TypeScript.  TypeScript is a language developed by Microsoft that gives 
                        the option to apply strict typing on top of JavaScript.  I wrote a discovery post on 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/03-Mar/3-8-TypeScript/View/typescript.html">TypeScript</a> 
                        that goes into more details about 
                        the features of the language and what I learned/liked about it from this Angular project.
                    </p>
                    <p>
                        I also wrote a discovery post about my 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/01-Jan/1-6-Angular-5-First-Impression/View/angular-first-imp.html">first impressions</a> 
                        of the Angular framework.  In that post I was a bit critical of the 
                        framework.  While I think Angular is far from perfect, it was definitely a joy to learn and work with.  It does have its issues 
                        which I will cover in this blog.  Another note is that this blog isn't going to teach beginners how to use Angular.  I expect that 
                        you have some knowledge about the framework and how it works.  I will go through all the major components of my application as well 
                        as other cool services, directives, etc.  Let’s get started by looking at the app component.  This component is the entry point for 
                        the application and holds all the routes through the single page application (SPA).
                    </p>
                    <h5>App Component</h5>
                    <p>
                        Before we look at the app component code directly, it is important to look at some of the code in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/app.module.ts">app.module.ts</a>.  
                        This module contains all the components except those for user profiles and cat posts.  It also defines 
                        the routes for my application.  Here are these route definitions:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">export const routes: Routes = [
    {path: '', component: HomeComponent},
    {path: 'user', loadChildren: './profile/profile.module#ProfileModule'},
    {path: 'about', component: AboutComponent},
    {path: 'login', component: LoginComponent},
    {path: 'signup', component: SignupComponent},
    {path: '**', redirectTo: ''}
];</code>
                        </pre>
                    </figure>
                    <p>
                        The user route is unique because it implements lazy loading.  This means that the module containing code for that route will not be loaded 
                        from the server until we traverse the route.  I discussed 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/01-Jan/1-27-Angular-5-Routing/View/angular-routing.html">Angular lazy loading</a> 
                        in more depth in a discovery post.
                    </p>
                    <p>
                        You may be wondering why the <code>AppComponent</code> is missing in these routes?  The AppComponent is actually the root component 
                        and it is bootstrapped into the module<sup>9</sup>.  It is defined in the <code>bootstrap</code> property on the <code>@NgModule</code> 
                        definition.  On app launch the <code>AppComponent</code> will then be bootstrapped and rendered by default. 
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">@NgModule({
    ...
    bootstrap: [AppComponent]
})</code>
                        </pre>
                    </figure>
                    <p>
                        The <code>AppComponent</code> template defines the navigation bar for the website.  Clicking on this navigation bar will change the 
                        route.  Based on the routes definition code shown before, different routes will display different components on the page.  The 
                        components will be displayed in the <code>&lt;router-outlet&gt;</code> element, as discussed further in my 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/01-Jan/1-27-Angular-5-Routing/View/angular-routing.html">discovery post</a>.
                          The code for the app components template is found in 
                          <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/app.component.html">app.component.html</a>
                    </p>
                    <p>
                        The navigation bar uses both Bootstrap and Sass for the styling.  In fact, all of the website uses a combination of Bootstrap and 
                        Sass for the UI.  While I really have loved Sass and how it modularizes my stylesheets and makes them easier to read and work with.  
                        I made a discovery post about 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/03-Mar/3-10-Sass/View/sass.html">Sass</a> 
                        if you want to learn more about how I used it in this prototype.  Bootstrap on the other hand I have mixed feelings about.  While it 
                        does have really cool components like the navbar I used for this website, it also comes with many frustrations.  For one the current 
                        state of Bootstrap has been a bit of a mess.  Different versions come with completely different non-backwards compatible naming 
                        conventions.  While this is confusing, to make matters worse the documentation online is not even up to date with the current release.  
                        This made developing with Bootstrap really frustrating.
                    </p>
                    <p>
                        If this was the only issue I had with Bootstrap I would suggest to wait for it to get into a more stable state before jumping onboard.  
                        However, I also found that many of the components weren’t as customizable as I would have liked.  This makes bootstrap seem like more of 
                        a fun pet project tool than something worth using in production.  I will discuss this lack of customizability in more detail when discussing 
                        the cat picture module.
                    </p>
                    <p>
                        The <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/app.component.ts">app.component.ts</a> 
                        code also subscribes to certain services that emit and receive messages to and from child components.  This allows 
                        for message passing between components.  I will go into detail about these services one I look at the child components that subscribe 
                        to them.
                    </p>
                    <p>
                        Now I want to look at the default route of the application which displays the <code>HomeComponent</code>.
                    </p>
                    <h5>Home Page</h5>
                    <figure id="maincomponent-image">
                        <img src="main-component.png">
                    </figure>
                    <p>
                        The code in the <code>HomeComponent</code> is pretty simple.  It subscribes to a service called <code>postService</code>.  By calling 
                        the <code>getAll()</code> function in <code>postService</code> the component will get all the cat posts stored on the server.  These will 
                        then be displayed in the UI.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">import { Component } from '@angular/core';
import {PostService} from "../post.service";
import {Post} from "../models/post";
import {environment} from "../../environments/environment";

@Component({
    selector: 'app-home',
    templateUrl: './home.component.html',
    styleUrls: ['./home.component.scss']
})
export class HomeComponent {
    posts: [Post];

    // The private modifier creates a new instance variable
    constructor(private postService: PostService) {

    // When the Observable getAll() value returns give it to the posts variable
    postService.getAll().subscribe(data => {

        this.posts = data;

        // Different behavior depending on environment
        if (environment.evt === 'dev') {
            this.posts.forEach(post => {
                post.date = new Date(post.date);
                post.picture = `${post.picture}`;
            });
        }
    });
    }
}</code>
                        </pre>
                    </figure>
                    <p>
                        The <code>postService</code> is one of the many services I created for this project.  It makes HTTP requests to the posts API.  
                        Here is a look at the service:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">import {Injectable} from '@angular/core';
import {Post} from "./models/post";
import {HttpClient} from "@angular/common/http";
import {Observable} from "rxjs/Observable";
import {HttpService} from "./http.service";

@Injectable()
export class PostService implements HttpService {

    constructor(private http: HttpClient) {}

    getAll(): Observable<[any]> {
        return this.http.get<[Post]>(`/api/post`);
    }

    get(id: number): Observable<any> {
        return this.http.get<Post>(`/api/post/${id}`);
    }

    post(post: Post): Observable<any> {
        return this.http.post<Post>(`/api/post`, post);
    }

    put(post: Post): Observable<any> {
        return this.http.put<Post>(`/api/post/${post.id}`, post);
    }

    delete(id: number): Observable<any> {
        return this.http.delete<any>(`/api/post/${id}`);
    }
}</code>
                        </pre>
                    </figure>
                    <p>
                        Each function in the service corresponds with a route defined in the Node.js <code>postRouter</code> API.  You can also see that the 
                        service implements a TypeScript interface.  The code for this interface is found in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/http.service.ts">http.service.ts</a>.  
                        I defined this interface to be implemented in all my HTTP request services.
                    </p>
                    <p>
                        The HTML template for the <code>HomeComponent</code> loops through the <code>posts</code> array and passes each post to the 
                        <code>CatPictureComponent</code>.  This component will display the cat post on the UI.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-html" title="HTML" contenteditable="true" spellcheck="false">&lt;div id="home-container" class="container-fluid mt-3"&gt;
    &lt;!-- Go through all the cat posts and pass each post to the cat-picture component --&gt;
    &lt;div class="card-columns"&gt;
        &lt;div *ngFor="let post of posts"&gt;
        &lt;cat-picture [post]="post"&gt;&lt;/cat-picture&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code>
                        </pre>
                    </figure>
                    <h5>Cat Posts</h5>
                    <p>
                        The <code>CatPictureComponent</code> displays the cat post details and picture in the UI.  It does this through the Bootstrap card 
                        component<sup>10</sup>.  The cards component makes displaying the cat posts in a resizable grid extremely easy.  The big problem I 
                        have with it is you can’t easily customize its default behavior.  By default the cards component displays each post from left to 
                        right.  This is a problem since now very old cat posts will show up near the top of the page.  Ideally I could easily change the 
                        behavior to populate the cards to populate from top to bottom instead.  However, Bootstrap does not allow for this customization.  
                        This is another reason why I feel like Bootstrap components aren’t quite adequate for the needs of a production level website.
                    </p>
                    <p>
                        Here is the HTML for <code>CatPictureComponent</code>.  Take a close look at the first <code>&lt;p&gt;</code> element and the 
                        <code>(click)</code> event and the <code>[routerLink]</code> Angular property.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-html" title="HTML" contenteditable="true" spellcheck="false">&lt;div class="card"&gt;
    &lt;img class="img-fluid cat-image" src={{post?.picture}} alt={{post?.picture}}&gt;
    &lt;div class="card-block mx-2"&gt;
        &lt;h4 class="card-title mt-2"&gt;{{post?.name}}&lt;/h4&gt;
        &lt;p class="card-text"&gt;
            &lt;small class="text-muted" (click)="emitUsername()"
                    [routerLink]="['../../user/profile', post?.username || '']"&gt;
                {{post?.first + " " + post?.last}}
            &lt;/small&gt;
        &lt;/p&gt;
        &lt;p class="card-text cat-post-date"&gt;
            &lt;small class="text-muted"&gt;
                {{post?.date.toDateString()}}
            &lt;/small&gt;
        &lt;/p&gt;
        &lt;p class="card-text cat-post-description"&gt;{{post?.description}}&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;</code>
                        </pre>
                    </figure>
                    <p>
                        The click event and router are placed on the name of the user who made the post.  This allows users to click the name and quickly view 
                        the uploaders profile.  Besides for changing the SPA route, the <code>emitUsername()</code> function is also called.  This function 
                        creates a message containing the posts username.  The <code>ProfileComponent</code> will subscribe to this emitted message so it knows 
                        which users information needs to be loaded.  The code for emitting the message is found in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/cat-picture/cat-picture.component.ts">cat-picture.component.ts</a> 
                        and the subscriber of the message is found in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/profile/profile.component.ts">profile.component.ts</a>.
                    </p>
                    <p>
                        While I don't mind setting up messaging between components, I wish there was a nicer way to store global data that would be used 
                        throughout the application.  This seems to be a bit of a weak point of the Angular framework, and I am curious how React.js will 
                        handle the same situation.
                    </p>
                    <h5>Login Page</h5>
                    <figure id="logincomponent-image">
                        <img src="login-component.png">
                    </figure>
                    <p>
                        The function of the <code>LoginComponent</code> is pretty self explanatory - it logs in a user!  This is where I ask for authentication 
                        from the server and get a JWT as a response.  I then store the JWT in <code>localStorage</code> and send it along with all HTTP requests 
                        to the server.  For more information on that process you can check out my discovery post on JWT.
                    </p>
                    <p>
                        The <code>LoginComponent</code> also uses the Angular forms API to easily create and validate form inputs.  I actually really liked working 
                        with the forms API.  It really simplified what is often the most convoluted part of a web application.  I remember how difficult it was to 
                        create a simple login and signup form on my first website (which was a LAMP stack website using JQuery in the frontend).  The Angular approach 
                        to forms is a welcome change!
                    </p>
                    <p>
                        I am not going to go into how the form API works, but you can check out the code for the login form in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/login/login.component.ts">login.component.ts</a> and 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/login/login.component.html">login.component.html</a>.  
                        A more complex example of the form API can be found in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/signup/signup.component.ts">signup.component.ts</a> and 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/signup/signup.component.html">signup.component.html</a>.
                    </p>
                    <figure id="signupcomponent-image">
                        <img src="signup-component.png">
                    </figure>
                    <p>
                        Another cool thing about the forms API is it is super easy to implement your own custom validator.  This validator can then be placed 
                        on any form element.  You can check out a custom validator I made which checks for whitespace in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/shared/no-whitespace.validator.ts">no-whitespace.validator.ts</a>.
                    </p>
                    <h5>Post Page</h5>
                    <p>
                        The post page is the most complex page in the website.  The component guides the user through a multi-part process of uploading a new cat 
                        post.  It involves the Angular forms API, picture file uploading, and calls to the Node.js posts API.
                    </p>
                    <p>
                        The component can be in three different states.  Each of these states presents a different UI for the user.  The first state allows the user 
                        to upload the cat posts details in an Angular form.  The second state allows them to upload a cat picture.  The third state is when the upload 
                        has been successfully made.
                    </p>
                    <p>
                        In order to display these three states, I used Angular’s <code>&lt;ng-template&gt;</code> HTML element.  This element is the Angular implementation 
                        of HTML’s native <code>&lt;template&gt;</code> element.  Anything in this element will not be rendered when the page is first loaded, but can be added 
                        to the page later on.  In my case the contents of <code>&lt;ng-template&gt;</code> will be rendered when certain variables in the <code>PostComponent</code> 
                        are set to <code>true</code>.
                    </p>
                    <p>
                        One of the big challenges I had with the <code>PostComponent</code> was getting the value in an HTML <code>&lt;input&gt;</code> 
                        element before it was destroyed.  This happened when the first state was destroyed and the second state was created.  The solution 
                        I ended up going with was setting up a spy directive on the <code>&lt;input&gt;</code> elements<sup>11</sup>.  This spy checks the lifecycles of 
                        the <code>&lt;input&gt;</code> element.  When it is created or destroyed I can then perform certain actions, such as initializing 
                        its value or retrieving its value.  Here is a look at the spy directive:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">import {Directive, ElementRef, OnDestroy, OnInit, Renderer2} from '@angular/core';
import {LifecycleService} from "./lifecycle.service";
import {Lifecycle} from "../models/lifecycle";

@Directive({
    selector: '[spy]'
})
export class SpyDirective implements OnInit, OnDestroy {

    constructor(private renderer: Renderer2, private el: ElementRef, 
                private lifecycleService: LifecycleService) {}

    /**
     * The initialization lifecycle for the spied upon element.  Send an appropriate 
     * notification to the lifecycle service for subscribers to consume.
     */
    ngOnInit(): void {
        const status: Lifecycle = this.lifecycleObject("init");

        this.lifecycleService.emitData(status);
    }

    /**
     * The destroy lifecycle for the spied upon element.  Send an appropriate 
     * notification to the lifecycle service for subscribers to consume.
     */
    ngOnDestroy(): void {
        const status: Lifecycle = this.lifecycleObject("destroy");

        this.lifecycleService.emitData(status);
    }

    lifecycleObject(event: string) : Lifecycle {
        return {
            id: this.el.nativeElement.id,
            event: event,
            value: this.el.nativeElement.value
        };
    }
}</code>
                        </pre>
                    </figure>
                    <p>
                        The <code>lifecycleService</code> allows for message passing between this directive and the <code>PostComponent</code>.  
                        You can look at this service in 
                        <a href="https://github.com/AJarombek/mean-client-prototype/blob/master/web-app/src/app/shared/lifecycle.service.ts">lifecycle.service.ts</a>.
                    </p>
                    <p>
                        Once again I think the message passing services are a bit of a messy approach to sharing data between components.  Maybe there is 
                        a better approach out there.  However, the fact that you can check the lifecycle of an HTML element through a directive is really 
                        cool!
                    </p>
                    <h5>Unit Testing Angular</h5>
                    <p>
                        I didn’t do much unit testing with my Angular application.  It is however set up with TravisCI and a testing suite just like the 
                        server side Node.js code.  I did write unit testing code to test some of the mock services in the project.  These mock services 
                        allowed me to work on the front-end code before the Node.js service was created.  This was really helpful during early 
                        development!  I will explain how I switched between environments in just a bit.
                    </p>
                    <p>
                        Here is an example of one of my mock services test code.  This one is for the user service:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false">import { TestBed, inject } from '@angular/core/testing';
import {MockUserService} from "./mock-user.service";
import {User} from "../models/user";

describe('MockUserService', () => {
    beforeEach(() => {
        TestBed.configureTestingModule({
            providers: [MockUserService]
        });
    });

    it('service should be created', inject([MockUserService], (service: MockUserService) => {
        expect(service).toBeTruthy();
    }));

    it("getAll() should get two users", inject([MockUserService], 
                                        (service: MockUserService) => {
        service.getAll().subscribe(users => {
            expect(users.length).toBe(2);
        });
    }));

    it("get() should get user 'andy'", inject([MockUserService], 
                                        (service: MockUserService) => {
        service.get("andy").subscribe(user => {
            expect(user.username).toBe('andy');
            expect(user.first).toBe('Andrew');
            expect(user.last).toBe('Jarombek');
        });
    }));

    it("post() should return new user", inject([MockUserService], 
                                        (service: MockUserService) => {
        service.post(new User("joe", "Joe", "Smith")).subscribe(user => {
            expect(user.username).toBe('joe');
            expect(user.first).toBe('Joe');
            expect(user.last).toBe('Smith');
        });
    }));

    ...
});</code>
                        </pre>
                    </figure>
                    <p>
                        When Angular CLI sets up components or services for you, it also generates a spec file that contains unit testing code for the 
                        component or service.  It only contains one test by default.  This test makes sure that the component or service loads properly.  
                        Although I wasn’t adding any more tests to the spec files, I found it really helpful to maintain the default test for each 
                        component.  This way I had to make sure all my components were following the code conventions of the Angular framework.  It 
                        even helped me to make design decisions.  For example, when the test code for a component became really difficult or impossible 
                        to maintain, I would realize it was time to create a new module to hold the component.  This is exactly what happened when I 
                        separated out the <code>CatPictureComponent</code> into its own module.
                    </p>
                    <h5>Dealing with Multiple Environments</h5>
                    <h5>Future Steps</h5>
                    <h5>Conclusions</h5>
                    <figure>
                        <pre>
                            <code class="language-typescript" title="TypeScript" contenteditable="true" spellcheck="false"></code>
                        </pre>
                    </figure>
                    <figure>
                        <pre class="command-line" data-prompt="$">
                            <code class="language-bash" title="Bash" contenteditable="true" spellcheck="false"></code>
                        </pre>
                    </figure>
                    <p>
                        The code for the prototype is available on my 
                        <a href="https://github.com/AJarombek/nodejs-mongodb-api-prototype">GitHub</a>. 
                    </p>
                    <div class="container tags">
                        <p>
                            Tags: <span class="badge badge-default">Angular</span> <span class="badge badge-default">Sass</span> <span class="badge badge-default">HTML</span>
                            <span class="badge badge-default">Bootstrap</span> <span class="badge badge-default">JWT</span> <span class="badge badge-default">TravisCI</span>
                            <span class="badge badge-default">MongoDB</span> <span class="badge badge-default">Node.js</span> <span class="badge badge-default">Express</span>
                            <span class="badge badge-default">JavaScript</span> <span class="badge badge-default">ECMAScript 6</span> <span class="badge badge-default">NoSQL</span> <span class="badge badge-default">Document Database</span>
                            <span class="badge badge-default">Mongoose</span> <span class="badge badge-default">TypeScript</span> <span class="badge badge-default">Webpack</span> <span class="badge badge-default">REST</span>
                        </p>
                    </div>
                    <div class="container sources">
                        <p>[1] "Introducing Mongoose 5.0.0-rc0", http://thecodebarbarian.com/introducing-mongoose-5.html</p>
                        <p>[2] "Helmet", https://helmetjs.github.io/</p>
                        <p>[3] Kyle Banker, Peter Bakkum, Shaun Verch, Douglas Garrett &amp; Tom Hawkins, MongoDB In Action, 2nd ed (Shelter Island, NY: Manning, 2016), 89</p>
                        <p>[4] Banker., 90</p>
                        <p>[5] Juho Vepsäläinen, SurviveJS: Webpack, (2017), xi</p>
                        <p>[6] Vepsäläinen., 259</p>
                        <p>[7] "__dirname returns '/' when js file is built with webpack", https://github.com/webpack/webpack/issues/1599</p>
                        <p>[8] "A guide to mocha's describe(), it() and setup hooks", https://samwize.com/2014/02/08/a-guide-to-mochas-describe-it-and-setup-hooks/</p>
                        <p>[9] Yakov Fain &amp; Anton Moiseev, Angular 2 Development with TypeScript (Shelter Island, NY: Manning, 2017), 33</p>
                        <p>[10] "Cards", http://v4-alpha.getbootstrap.com/components/card/</p>
                        <p>[11] "Spying OnInit and OnDestroy", https://angular.io/guide/lifecycle-hooks#spy</p>
                    </div>
                </div>
            </div>
        </div>
        <script src="../../../prism.js"></script>
    </body>
</html>