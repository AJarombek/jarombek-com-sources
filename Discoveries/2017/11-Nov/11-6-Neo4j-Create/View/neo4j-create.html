<!DOCTYPE html>
<!-- Author: Andrew Jarombek
     Date: 11/6/2017 -->
<html>
    <head>
        <meta chartset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Creating a Simple Geographical Map with Neo4j and Cypher</title>
        <link rel="stylesheet" href="style/neo4j-create.css">
        <link rel="stylesheet" href="../../../../../blog-discover.css">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/fantasque-sans-mono" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" 
            integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
        <link href="../../../../../prism.css" rel="stylesheet" />
    </head>
    <body>
        <div class="col-md-12 discoveryBody">
            <div class="col-md-12 discoveryContent">
                <p class="date">November 6th, 2017</p>
                <br>
                <h4>Creating a Simple Geographical Map with Neo4j and Cypher</h4>
                <br>
                <div class="container aknowledge">
                    <p>Assumed Knowledge:</p>
                    <p>Graph Databases <span class="badge badge-default">Basic</span></p>
                    <p>Neo4j <span class="badge badge-default">Basic</span></p>
                    <p>Cypher Query Language <span class="badge badge-default">Basic</span></p>
                </div><br>
                <div id="discoveryText" class="container">
                    <p>
                        Lately I have been reading up on graph databases and their place in the NoSQL data storage universe.
                        The graph database I've worked with is Neo4j, which is very easy to get set up.  I've found the user interface
                        to view graphs and type in queries to be very enjoyable and I highly recommend it if you need a graph database solution.
                    </p>
                    <p>
                        Without going into too much detail, the largest draw to graph databases is storing relationships between data and the 
                        speed at which you can query related data points (or in graph terms nodes/vertices). Relationships are first class citizens
                        in graph databases which allows you to query related data by traversing the relationship itself.  This is contrasted with a 
                        typical relational database solution where you have to find relationships through foreign keys or combine two tables of data 
                        with a very slow SQL JOIN operation<sup>1</sup>.  Our same slow query in a RDBMS (Relational DataBase Management System) is extremely quick
                        in a graph database.
                    </p>
                    <p>
                        One of the first graphs I made in Neo4j represented the county I grew up in - 
                        <a href="https://i.pinimg.com/736x/32/10/06/3210060e2e11b84a497e7b56dac7fbb8--connecticut-ancestry.jpg">Fairfield County CT</a>.  
                        The first task on my list was to create a vertex to represent a state - in this case Connecticut.  In Cypher (the query language used by Neo4j) 
                        that is easy!
                    </p>
                    <figure>
                        <pre class="line-numbers">
                            <code class="language-clike" title="Cypher" contenteditable="true" spellcheck="false">CREATE (ct:State {name: 'Connecticut'}) RETURN ct</code>
                        </pre>
                    </figure>
                    <p>
                        We use the <code>CREATE</code> statement to build a vertex and pass it a label <code>:State</code> and a property <code>name</code>.  The label 
                        is used for grouping, in this case all states will have the label <code>:State</code>. You can also name the vertex along with supply additional 
                        key->value information in the vertices properties.
                    </p>
                    <p>
                        You can also create multiple vertices from a single <code>CREATE</code> statement.  I will utilize this to populate the counties towns and cities:
                    </p>
                    <figure>
                        <pre class="line-numbers">
                            <code class="language-clike" title="Cypher" contenteditable="true" spellcheck="false">CREATE (:City {name: 'Bridgeport'}),
    (:City {name: 'Danbury'}),
    ...
    
CREATE (:Town {name: 'Bethel'}),
    (:Town {name: 'Brookfield'}),
    ...</code>
                        </pre>
                    </figure>
                    <p>
                        Before I create any relationships, I want to make life easier and group together cities and towns under one common label.  After all they are 
                        both considered settlements.
                    </p>
                    <figure>
                        <pre class="line-numbers">
                            <code class="language-clike" title="Cypher" contenteditable="true" spellcheck="false">MATCH (s) WHERE s:City OR s:Town SET s:Settlement</code>
                        </pre>
                    </figure>
                    <p>
                        I introduced some new keywords here. Most important of them is <code>MATCH</code> which queries the database based on some ASCII Art that I pass it.  
                        The <code>(...)</code> token represents a node in the database which I assign to variable <code>s</code>.  So this query says "for each vertex in the
                        database that is a city or town set a new label called Settlement".  In Neo4j a vertex can have multuple labels so this <code>SET</code> operation will
                        not override the old labels.
                    </p>
                    <p>
                        Now it is time for the fun part: relationships.  Lets create a relationship between all the settlements and the state of Connecticut:
                    </p>
                    <figure>
                        <pre class="line-numbers">
                            <code class="language-clike" title="Cypher" contenteditable="true" spellcheck="false">MATCH (ct:State), (s:Settlement) MERGE (ct)<-[:IN]-(s)</code>
                        </pre>
                    </figure>
                    <p>
                        As you likely guessed, the ASCII art for a relationship is <code><-[:IN]-</code> where the arrow shows the direction of the relationship.  We also give the
                        relationship a label, in this case <code>:IN</code>.  We could also give a relationship properties just like you would a vertex.  This is what I meant by 'relationships are
                        first class entities' - they are treated and can be queried just like a vertex!  This is extremely powerful.
                    </p>
                    <p>
                        You may have noticied that in this query we match for multiple vertices.  In this case, we want all the vertices where the label is State or Settlement.  Then
                        we create the relationship "settlement is in state".  Since the only state in the database is Connecticut, this simple query will give us the intended result.
                    </p>
                    <p>
                        For the final step of this graph we want to create relationships between all the neighboring towns.  This is a long query so I'll just show a snippet (the full code
                        for this and the other snippets can be found 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2017/11-Nov/11-6-Neo4j-Create/Source/neo4j-create.cql">HERE</a>):
                    </p>
                    <figure>
                        <pre class="line-numbers">
                            <code class="language-clike" title="Cypher" contenteditable="true" spellcheck="false">MATCH (greenwich:Settlement {name: 'Greenwich'}),
    (stamford:Settlement {name: 'Stamford'}),
    (newcannan:Settlement {name: 'New Cannan'}),
    (darien:Settlement {name: 'Darien'}),
    ...
CREATE (greenwich)-[:NEIGHBORS_OF]->(stamford),
    (stamford)-[:NEIGHBORS_OF]->(newcannan),
    (stamford)-[:NEIGHBORS_OF]->(darien),
    ...</code>
                        </pre>
                    </figure>
                    <p>
                        In this code we first want to give variables for all the settlement nodes by their name.  Then we want to create neighbors relationships between towns that 
                        share borders.  One thing that I questioned when writing this code is 'why cant their be bi-directional relationships?'  It turns out at the time of this writing
                        Neo4j does not support  bi-directional relationships.  This is because traversing a realtionship takes the same amount of time (O(1)) regardless of the direction it is 
                        pointing<sup>2</sup>.  In a case like this one where we will treat the relationships as bi-directional, you can just ignore the arrow in <code>MATCH</code> queries.  Below you
                        can see the output of the settlements in the Neo4j user interface:
                    </p>
                    <figure>
                        <img src="FairfieldGraphImage.png">
                    </figure>
                    <p>
                        I will look further at Neo4j and build off this graph in future discoveries.  I hope this shows you just how simple it is to build a graph database!
                    </p>
                    <div class="container tags">
                        <p>
                            Tags: <span class="badge badge-default">Neo4j</span> <span class="badge badge-default">Cypher Query Langauge</span> 
                                <span class="badge badge-default">Graph Database</span> <span class="badge badge-default">NoSQL</span>
                        </p>
                    </div>
                    <div class="container sources">
                        <p>[1] Ian Robinson, Jim Webber & Emil Eifrem, Graph Databases (Beijing: O'Reilly, 2015), 6</p>
                        <p>[2] Ibid., 152</p>
                    </div>
                </div>
            </div>
        </div>
        <script src="../../../../../prism.js"></script>
    </body>
</html>