<!DOCTYPE html>
<!-- Author: Andrew Jarombek
     Date: 2/17/2018 -->
<html>
    <head>
        <meta chartset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Oracle 12c Database Up &amp; Running</title>
        <link rel="stylesheet" href="../../../../../blog-discover.css">
        <link rel="stylesheet" href="style/oracle-start.css">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/fantasque-sans-mono" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" 
            integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
        <link href="../../../../../prism.css" rel="stylesheet" />
    </head>
    <body>
        <div class="col-md-12 discoveryBody">
            <div class="col-md-12 discoveryContent">
                <p class="date">Feburary 12th, 2018</p>
                <br>
                <h4>Oracle 12c Database Up &amp; Running</h4>
                <br>
                <div class="container aknowledge">
                    <p>Assumed Knowledge:</p>
                    <p>SQL <span class="badge badge-warning">Intermediate</span></p>
                    <p>Relational Database <span class="badge badge-warning">Intermediate</span></p>
                    <p>Oracle Database <span class="badge badge-default">Basic</span></p>
                </div><br>
                <div id="discoveryText" class="container">
                    <p>
                        I recently finished looking at Java 8 (which was the topic of recent discoveries) and now am doing a deep dive into the Oracle database.  
                        Although I don't use Oracle a ton in my free time I use it a lot at work and it is the 
                        <a href="http://pypl.github.io/DB.html">most popular database</a> at the moment.  Therefore it is good to know well!
                    </p>
                    <p>
                        This discovery is going to follow me through the setup of my database.  I will skip the actually Oracle installation and configuration 
                        (which was a challenge itself!) and skip straight to the moment I started typing SQL.
                    </p>
                    <p>
                        A disclaimer before I begin.  A lot of my discoveries are about languages and technologies that I really love using.  In this case I 
                        wouldn't say that I love Oracle but it is a good tool to have in the kit.  Just try installing an Oracle product and you will begin to 
                        see why many get frustrated with this database!  One bright spot would be the PL/SQL language, which allows developers to add some 
                        really cool functionality at the database layer of applications.  I won't be going into PL/SQL much this time around but definitely 
                        will in the future!
                    </p>
                    <h5>Basic Administration</h5>
                    <p>
                        So to start out I installed Oracle (the only good installation guide was found on a non-Oracle backed 
                        <a href="https://www.codeproject.com/Articles/1027230/Oracle-c-Installation-on-Windows-Step-by-Step">blog post</a>) and connected to my 
                        database instance.  The first task I wanted to accomplish was create a user for my database schema.  In Oracle a user is an account for 
                        a schema of the same name<sup>1</sup>.
                    </p>
                    <p>
                        I started by creating a tablespace called <code>ANDY</code> that I would place all my tables in.  A tablespace in Oracle consists of 
                        physical storage units for the database's data<sup>2</sup>.  It is a way to group the database at a storage level.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-markup" title="SQL" contenteditable="true" spellcheck="false">CREATE TABLESPACE ANDY;

CREATE USER C##ANDYUSR IDENTIFIED BY orac1et3st DEFAULT TABLESPACE ANDY;
GRANT ALL PRIVILEGES TO C##ANDYUSR;</code>
                        </pre>
                    </figure>
                    <p>
                        Next I create my user <code>C##ANDYUSR</code> and give it all privileges.  I also set its default tablespace to the one I just created.  
                        You may be wondering what is up with the strange username?  The <code>C##</code> prefix defines a common user (contrasted with a local 
                        user)<sup>3</sup>.  A common user can be used across all Oracle pluggable databases instead of being local to a single one.  You can 
                        confirm that the user is a common user with the following query:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">SELECT * FROM ALL_USERS WHERE USERNAME LIKE 'C##%';</code>
                        </pre>
                    </figure>
                    <figure id="common-user-image">
                        <img src="common-user.png">
                    </figure>
                    <p>
                        So what is a pluggable database?  It is a new feature in Oracle 12c that allows you to define many databases inside a container database 
                        instance<sup>4</sup>.  This allows for users to control multiple databases while only running one instance of Oracle 12c.  I am going to 
                        ignore the pluggable database feature for the rest of the discovery but I want to breifly show how you could create a user for a 
                        pluggable database.
                    </p>
                    <p>
                        In SQL*Plus you can change the current session to a pluggable database with the following command:
                    </p>
                    <figure>
                        <pre class="command-line" data-prompt=">" data-output="2">
                            <code class="language-bash" title="Bash" contenteditable="true" spellcheck="false">alter session set container=CAPYBARA1</code>
                        </pre>
                    </figure>
                    <p>
                        From here you can simply create a new user like before but without the <code>C##</code> prefix:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">CREATE USER ANDYUSR IDENTIFIED BY orac1et3st DEFAULT TABLESPACE ANDY;
GRANT ALL PRIVILEGES TO ANDYUSR;</code>
                        </pre>
                    </figure>
                    <p>
                        Now let's move on to building the basic table structure of the database!
                    </p>
                    <h5>Table Creation</h5>
                    <p>
                        The database is going to store books that I have read.  These books also have a many-to-many relationship to programming languages 
                        (since a book can be about many languages and a language can have many books describing it).  The first table I added was for languages.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">-- I was thinking of using a sequence to generate a primary key for this table.  
-- However, Oracle 12c introduced identity columns which simplifies sequence
-- generation statements on columns
CREATE TABLE languages(
    language_id INTEGER GENERATED BY DEFAULT AS IDENTITY (
    START WITH 1 INCREMENT BY 1
    ),
    name VARCHAR2(63),
    created DATE
) TABLESPACE ANDY;

ALTER TABLE languages ADD CONSTRAINT languages_id_pk PRIMARY KEY (language_id);

-- All language name values must be unique in the table
-- Specifying a unique constraint also creates an index on the column
ALTER TABLE languages ADD CONSTRAINT languages_name_uq UNIQUE (name);</code>
                        </pre>
                    </figure>
                    <p>
                        Some interesting aspects of this table is that each language has an id that is auto incremented.  This means that you don't actually 
                        assign a language an id, Oracle will generate one for you on request.
                    </p>
                    <p>
                        The second table was for books:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">CREATE TABLE books(
isbn INTEGER CONSTRAINT books_pk PRIMARY KEY,
title VARCHAR2(127),
released DATE
) TABLESPACE ANDY;

-- Since I don't give a name to this constraint, Oracle automatically generates one for me
ALTER TABLE books MODIFY title NOT NULL;

-- Add columns to the existing table
ALTER TABLE books ADD started DATE;
ALTER TABLE books ADD finished DATE;
ALTER TABLE books ADD edition INTEGER;

-- Add a virtual column that determines the number of days spent reading the book
ALTER TABLE books ADD (time_reading AS (finished - started));

-- Add some check constraints to the book table.  This will validate incoming data
ALTER TABLE books ADD CONSTRAINT books_isbn_ck CHECK (isbn > 0);
ALTER TABLE books ADD CONSTRAINT books_dates_ck CHECK (finished >= started);

-- Add indexes on commonly queried columns.  Best practice is to create an index when you have queries on a column that
-- retrieve less than 10 percent of the total rows in the table
CREATE INDEX i_books_title ON books(title);</code>
                        </pre>
                    </figure>
                    <p>
                        The first really cool thing about this table is the <code>time_reading</code> column.  This is a virtual column, a feature added in 
                        Oracle 11g.  Virtual columns aren't actually stored on disk, instead they are dynamically generated by performing computations on other 
                        columns in the table<sup>5</sup>.  The virtual column I defined subtracts the date I started reading from the date I finished, 
                        displaying the number of days spent reading the book!
                    </p>
                    <p>
                        The second cool piece to this table is that some of the columns have <code>CHECK</code> constraints on them.  These constraints 
                        enforce rules on the data users try to put into the columns<sup>6</sup>.  The first constraint makes sure that the ISBN number is 
                        greater than zero, and the second constraint checks that the finished date occurs after (or at the same time as) the start date.  
                        These <code>CHECK</code> constraints allow you to add some validation logic on database columns!
                    </p>
                    <p>
                        Finally I created the <code>book_languages</code> table that stores the many to many relationship between books and languages:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">CREATE TABLE book_languages(
    isbn INTEGER NOT NULL,
    name VARCHAR2(63),
    CONSTRAINT books_languages_isbn_fk
    FOREIGN KEY (isbn) REFERENCES books(isbn) ON DELETE CASCADE,
    CONSTRAINT book_languages_name_fk
    FOREIGN KEY (name) REFERENCES languages(name) ON DELETE CASCADE
) TABLESPACE ANDY;</code>
                        </pre>
                    </figure>
                    <p>
                        You can see that both the columns in this table are actually foreign keys by looking at their constraints!
                    </p>
                    <h5>Table Population</h5>
                    <p>
                        First I populated both the languages and books tables:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">-- Although permitted to do so, do not insert into the auto generated identity column
INSERT INTO languages(
    name, created
) VALUES (
    'Java', '23-MAY-1995'
);

INSERT INTO languages(
    name, created
) VALUES (
    'SQL', '01-JAN-1974'
);

INSERT INTO languages(
    name, created
) VALUES (
    'PL/SQL', '01-JAN-1992'
);

INSERT INTO languages(
    name, created
) VALUES (
    'JavaScript', '04-DEC-1995'
);

-- You are not allowed to insert into virtual columns.  So if you try to insert into 
-- time_reading, you get the error: 
-- ORA-54013: INSERT operation disallowed on virtual columns
INSERT INTO books(
    isbn, title, released, started, finished, edition
) VALUES (
    9781617291999, 'Java 8 in Action', '01-AUG-2014', '10-OCT-2017', '08-FEB-2018', 1
);

INSERT INTO books(
    isbn, title, released, started, finished, edition
) VALUES (
    9780071799355, 'Oracle Database 12c SQL', '10-SEP-2013', '02-SEP-2017', '28-SEP-2017', 1
);

INSERT INTO books(
    isbn, title, released, started, finished, edition
) VALUES (
    9781491901946, 'AngularJS: Up and Running', '01-SEP-2014', '15-JUN-2017', NULL, 1
);</code>
                        </pre>
                    </figure>
                    <p>
                        Writing out each insert statement is a bit of overhead, so for the <code>book_languages</code> I created a PL/SQL procedure to do it for 
                        me!  In PL/SQL, a procedure is just a function with no output value.  This is perfect for doing some inserts!
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">DECLARE
PROCEDURE bulk_insert(
    p_isbn IN INTEGER,
    p_name IN VARCHAR2
) AS
BEGIN
    INSERT INTO book_languages(
    isbn, name
    ) VALUES (
    p_isbn, p_name
    );
END;
BEGIN
    bulk_insert(p_isbn => 9781617291999, p_name => 'Java');
    bulk_insert(p_isbn => 9780071799355, p_name => 'SQL');
    bulk_insert(p_isbn => 9780071799355, p_name => 'PL/SQL');
    bulk_insert(p_isbn => 9781491901946, p_name => 'JavaScript');
END;

SELECT * FROM book_languages;</code>
                        </pre>
                    </figure>
                    <figure id="bulk-insert-image">
                        <img src="bulk-insert.png">
                    </figure>
                    <p>
                        I'll dive more into PL/SQL later.  Now the database is fully set up and ready to query (which I will do next time).  The full code for 
                        this discovery (with some nice comments!) is up on 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/02-Feb/2-12-Oracle-Start/Source">GitHub</a>.
                    </p>
                    <div class="container tags">
                        <p>
                            Tags: <span class="badge badge-default">SQL</span> <span class="badge badge-default">Relational Database</span> 
                                <span class="badge badge-default">Oracle Database</span>
                        </p>
                    </div>
                    <div class="container sources">
                        <p>[1] "Difference between database vs user vs schema", https://dba.stackexchange.com/questions/37012/difference-between-database-vs-user-vs-schema</p>
                        <p>[2] "Tablespaces, Datafiles, and Control Files", https://docs.oracle.com/cd/B19306_01/server.102/b14220/physical.htm</p>
                        <p>[3] "CREATE USER", https://docs.oracle.com/database/121/SQLRF/statements_8003.htm#SQLRF01503</p>
                        <p>[4] Jason Price, Oracle Database 12c SQL (New York: McGraw-Hill Education, 2013), 295</p>
                        <p>[5] Ibid., 340</p>
                        <p>[6] Ibid., 343</p>
                    </div>
                </div>
            </div>
        </div>
        <script src="../../../../../prism.js"></script>
    </body>
</html>