<!DOCTYPE html>
<!-- Author: Andrew Jarombek
     Date: 2/17/2018 -->
<html>
    <head>
        <meta chartset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Oracle: Advanced Queries Part I</title>
        <link rel="stylesheet" href="../../../../../blog-discover.css">
        <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
        <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/fantasque-sans-mono" type="text/css"/>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" 
            integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
        <link href="../../../../../prism.css" rel="stylesheet" />
    </head>
    <body>
        <div class="col-md-12 discoveryBody">
            <div class="col-md-12 discoveryContent">
                <p class="date">March 18th, 2018</p>
                <br>
                <h4>Oracle: Advanced Queries Part I</h4>
                <br>
                <div class="container aknowledge">
                    <p>Assumed Knowledge:</p>
                    <p>SQL <span class="badge badge-warning">Intermediate</span></p>
                    <p>Relational Database <span class="badge badge-warning">Intermediate</span></p>
                    <p>Oracle Database <span class="badge badge-warning">Intermediate</span></p>
                </div><br>
                <div id="discoveryText" class="container">
                    <p>
                        Here in the third installment of my Oracle discoveries, I dig into analytic functions and some more 
                        advanced queries.  Nothing too out of this world crazy, but I definitely explored some SQL syntax that 
                        I had never seen before.  The 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/03-Mar/3-2-Oracle-Queries/View">first</a> discovery 
                        saw me create a new database and set up the basic tables.  In the 
                        <a href="https://github.com/AJarombek/jarombek-com-submittions/blob/master/Discoveries/2018/02-Feb/2-12-Oracle-Start/View">second</a> 
                        I did some more intermediate level queries on the database.  Now I will continue building 
                        off this knowledge!  These are some more advanced queries that I found really cool!
                    </p>
                    <p>
                        The database I built contains books I have read and different programming languages I have used.  There is also a relationship 
                        between books and languages, since all the books are about programming!
                    </p>
                    <p>
                        The first analytic function calculation I performed was a ranking of programming languages and the time spent reading about them.  
                        There are two main functions that you can use for ranking, <code>RANK()</code> and <code>DENSE_RANK()</code>.  The only difference 
                        between the two is the way that they handle ties in the rankings<sup>1</sup>.  You can see this difference in action with the following 
                        query and the ranking given to the JavaScript language.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">SELECT
    l.name,
    SUM(b.time_reading),
    RANK() OVER (ORDER BY SUM(b.time_reading) DESC NULLS LAST) AS rank,
    DENSE_RANK() OVER (ORDER BY SUM(b.time_reading) DESC NULLS LAST) AS dense_rank
FROM books b
INNER JOIN book_languages l ON b.isbn = l.isbn
GROUP BY l.name
ORDER BY rank;</code>
                        </pre>
                    </figure>
                    <span class="code-span">
NAME         SUM(B.TIME_READING) RANK      DENSE_RANK
------------ ------------------- --------- ---------------
Java         134                 1         1
PL/SQL       26                  2         2
SQL          26                  2         2
JavaScript  
                    </span>
                    <p>
                        Another interesting piece to this query is the <code>NULLS LAST</code> clause.  By default when ordering <code>null</code> values come 
                        first.  In this case however null is equivalent to zero days spent reading, so we want them to come last.  The <code>NULLS LAST</code> 
                        clause performs this switch when ordering.
                    </p>
                    <p>
                        When performing rankings, you can also partition the ranks into subgroups by specifying a <code>PARTITION BY</code> column.  This is a 
                        bit too complex an operation for our basic <code>book_languages</code> table, so I am going to create a new table called 
                        <code>code_written</code> that we can use for the rest of the examples.  This table contains a year, a language, and the number of lines 
                        of code I wrote in that language for the year (these are real statistics!):
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false"></code>
                        </pre>
                    </figure>
                    <p>
                        Now on this new table we can partition our rankings based on the year, creating a new yearly ranking!
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">SELECT
    year,
    language,
    lines,
    RANK() OVER (PARTITION BY year ORDER BY lines DESC) AS yearly_rank,
    RANK() OVER (ORDER BY lines DESC) AS all_time_rank
FROM code_written
ORDER BY year, yearly_rank;</code>
                        </pre>
                    </figure>
                    <span class="code-span">
YEAR    LANGUAGE       LINES           YEARLY_RANK     ALL_TIME_RANK
------- -------------- --------------- --------------- ---------------
2014	Java           4282            1               7
2015	Java           1585            1               14
2015	Python         931             2               23
2015	C              630             3               27
2015	XML            42              4               40
2015	JSON           32              5               42
2016	Java           12962           1               1
2016	PHP            5433            2               6
2016	XML            2646            3               9
2016	JavaScript     2008            4               10
2016	HTML           1413            5               15
....    ....           ....            .               ..
                    </span>
                    <p>
                        You can do other types of rankings such as percentile rankings.  From this we can see that the total lines for Java in 2015 was in the 
                        top 30% performances across all years.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">SELECT
    year,
    language,
    lines,
    ROUND(PERCENT_RANK() OVER (PARTITION BY year ORDER BY lines DESC), 2) AS yearly_distribution,
    ROUND(PERCENT_RANK() OVER (ORDER BY lines DESC), 2) AS all_time_distribution
FROM code_written
ORDER BY year, yearly_distribution;</code>
                        </pre>
                    </figure>
                    <span class="code-span">
YEAR     LANGUAGE     LINES           YEARLY_DISTRIBUTION ALL_TIME_DISTRIBUTION
-------- ------------ --------------- ------------------- ---------------------
2014	 Java         4282            0                   0.14
2015	 Java         1585            0                   0.3
2015     Python       931             0.25                0.5
2015     C            630             0.5                 0.59
2015     XML          42              0.75                0.89
2015     JSON         32              1                   0.93
2016     Java         12962           0                   0
2016     PHP          5433            0.1                 0.11
2016     XML          2646            0.2                 0.18
2016     JavaScript   2008            0.3                 0.2
2016     HTML         1413            0.4                 0.32
....     ....         ....            ...                 ....
                    </span>
                    <p>
                        The following query tries to find the median value for each language.  The implementation of this function goes a bit over my head<sup>2</sup>!
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">SELECT
    language,
    PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY lines DESC) AS median
FROM code_written GROUP BY language;</code>
                        </pre>
                    </figure>
                    <span class="code-span">
LANGUAGE              MEDIAN
--------------------- ----------
C                     325
CSS                   1233
HTML                  1413
JSON                  466
Java                  4282
JavaScript            2008
PHP                   3670
PL/SQL                203
Python                1026.5
SQL                   812
Sass                  303
Swift                 5414.5
TypeScript            991.5
XML                   1344
                    </span>
                    <p>
                        The next couple queries all utilize window functions.  Window functions apply an aggregate function such as <code>AVG()</code> or 
                        <code>SUM()</code> to a subset of rows from a result set<sup>3</sup>.  This subset is known as the window.  Here is an example of 
                        query using a window function that shows the cumulative sum of code lines written:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">SELECT
    year,
    SUM(lines) AS total_lines,
    SUM(SUM(lines)) OVER (ORDER BY year ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as cumulative_lines
FROM code_written
GROUP BY year;</code>
                        </pre>
                    </figure>
                    <span class="code-span">
YEAR     TOTAL_LINES CUMULATIVE_LINES
----- -------------- ----------------
2014            4282             4282
2015            3220             7502
2016           29161            36663
2017           47140            83803
2018            5986            89789
                    </span>
                    <p>
                        The column aliased as <code>cumulative_lines</code> is the really interesting one here.  It starts by saying compute the sum of all the 
                        rows in the window with the statement <code>SUM(SUM(lines))</code>.  Now I have to define what rows are in the window.  I 
                        <code>ORDER BY year</code> so that we accumulate the sum in yearly order.  This is enforced with <code>ROWS BETWEEN UNBOUNDED PRECEDING 
                            AND CURRENT ROW</code>, which states that the window consists of this row and all the rows that came prior.
                    </p>
                    <p>
                        You can perform other really cool data analysis with window functions such as moving averages and centered averages.  I show both of 
                        these examples below.  Look closely at how the window is defined in each query.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">-- Perform a moving average by specifying that the current row and two preceding rows will be included in the
-- window calculation of AVG()
SELECT
    year,
    SUM(lines) AS total_lines,
    AVG(SUM(lines)) OVER (ORDER BY year ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as cumulative_lines
FROM code_written
GROUP BY year;

-- Perform a centered average by specifying that the window consists of the current row, the previous row, and the
-- next row.
SELECT
    year,
    SUM(lines) AS total_lines,
    AVG(SUM(lines)) OVER (ORDER BY year ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) as cumulative_lines
FROM code_written
GROUP BY year;</code>
                        </pre>
                    </figure>
                    <p>
                        If you want to get a certain value in a window, you can use the <code>FIRST_VALUE()</code> function to get the first row in the 
                        window, <code>LAST_VALUE</code> to get the last row, or <code>NTH_VALUE()</code> to get any other row.  When the first value in the 
                        window is predictable beforehand you can do really powerful things with this function.  For example, in the following query I know 
                        that <code>FIRST_VALUE()</code> will return the previous years total lines written every time.   I can use this knowledge to perform 
                        comparisons between the row in the query and the first row in the window, such as the percent change between the two:
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">SELECT
    year,
    SUM(lines) AS total_lines,
    FIRST_VALUE(SUM(lines)) OVER (ORDER BY year ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS last_year_total,
    ROUND(SUM(lines)/FIRST_VALUE(SUM(lines)) OVER (ORDER BY year ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) * 100, 2)
      || '%' AS percent_change
FROM code_written
GROUP BY year;</code>
                        </pre>
                    </figure>
                    <span class="code-span">
YEAR       TOTAL_LINES LAST_YEAR_TOTAL PERCENT_CHANGE
------ --------------- --------------- ---------------
  2014            4282            4282 100%
  2015            3220            4282 75.2%
  2016           29161            3220 905.62%
  2017           47140           29161 161.65%
  2018            5986           47140 12.7%
                    </span>
                    <p>
                        The final query I will show in this discovery lists all the languages used each year ordered from most used to least used.  You can 
                        combine strings from a column across multiple rows with the <code>LISTAGG()</code> function along with the <code>WITHIN GROUP</code> 
                        clause.
                    </p>
                    <figure>
                        <pre>
                            <code class="language-sql" title="SQL" contenteditable="true" spellcheck="false">SELECT
    year,
    LISTAGG(language, ', ') WITHIN GROUP (ORDER BY year, lines desc) AS languages_used,
    SUM(lines) as total_lines
FROM code_written
GROUP BY year;</code>
                        </pre>
                    </figure>
                    <span class="code-span">
YEAR  LANGUAGES_USED                                TOTAL_LINES
----- --------------------------------------------- ------------
2014  Java                                          4282
2015  Java, Python, C, XML, JSON                    3220
2016  Java, PHP, XML, JavaScript, HTML, ...         29161
2017  Java, Swift, JavaScript, XML, PHP, ...        47140
2018  TypeScript, JavaScript, Java, SQL, ...        5986
                    </span>
                    <p>
                        Next time I will look at the <code>MODEL</code> clause and the incredibly cool <code>PIVOT</code> clause that allows you to pivot a 
                        table on a certain column!
                    </p>
                    <div class="container tags">
                        <p>
                            Tags: <span class="badge badge-default">SQL</span> <span class="badge badge-default">Relational Database</span> 
                                <span class="badge badge-default">Oracle Database</span>
                        </p>
                    </div>
                    <div class="container sources">
                        <p>[1] Jason Price, Oracle Database 12c SQL (New York: McGraw-Hill Education, 2013), 240</p>
                        <p>[2] "PERCENTILE_CONT", http://psoug.org/definition/PERCENTILE_CONT.htm</p>
                        <p>[3] Ibid., 247</p>
                    </div>
                </div>
            </div>
        </div>
        <script src="../../../../../prism.js"></script>
    </body>
</html>